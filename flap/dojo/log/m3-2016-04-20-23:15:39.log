waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
automatic:140/183
Trace:
=> J'ai trouvé une archive.
=> Je la décompresse.
flap-uzenat-elouraoui-15.3/
flap-uzenat-elouraoui-15.3/myocamlbuild_config.ml
flap-uzenat-elouraoui-15.3/Makefile.local
flap-uzenat-elouraoui-15.3/src/
flap-uzenat-elouraoui-15.3/src/retrolix/
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixLexer.mll
flap-uzenat-elouraoui-15.3/src/retrolix/graph.ml
flap-uzenat-elouraoui-15.3/src/retrolix/fopixToRetrolix.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/retrolix/graphColoring.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixParser.mly
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixInitialization.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixCompression.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixRegisterAllocation.ml
flap-uzenat-elouraoui-15.3/src/retrolix/graph.mli
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixAST.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolix.ml
flap-uzenat-elouraoui-15.3/src/fopix/
flap-uzenat-elouraoui-15.3/src/fopix/fopix.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/fopix/hobixToFopix.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixInitialization.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixAST.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixLexer.mll
flap-uzenat-elouraoui-15.3/src/fopix/fopixParser.mly
flap-uzenat-elouraoui-15.3/src/fopix/fopixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/version.ml
flap-uzenat-elouraoui-15.3/src/common/
flap-uzenat-elouraoui-15.3/src/common/compilers.ml
flap-uzenat-elouraoui-15.3/src/common/languages.ml
flap-uzenat-elouraoui-15.3/src/options.ml
flap-uzenat-elouraoui-15.3/src/hopix/
flap-uzenat-elouraoui-15.3/src/hopix/memory.mli
flap-uzenat-elouraoui-15.3/src/hopix/hopixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/hopix/memory.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixLexer.mll
flap-uzenat-elouraoui-15.3/src/hopix/hopixAST.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixParser.mly
flap-uzenat-elouraoui-15.3/src/hopix/hopix.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixTypes.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixInitialization.ml
flap-uzenat-elouraoui-15.3/src/lib/
flap-uzenat-elouraoui-15.3/src/lib/pprint/
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintEngine.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/LICENSE
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintOCaml.mli
flap-uzenat-elouraoui-15.3/src/lib/pprint/CHANGES
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintRenderer.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintEngine.mli
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrint.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/AUTHORS
flap-uzenat-elouraoui-15.3/src/lib/pprint/README
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintCombinators.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintCombinators.mli
flap-uzenat-elouraoui-15.3/src/lib/pprint/Makefile
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintOCaml.ml
flap-uzenat-elouraoui-15.3/src/hobix/
flap-uzenat-elouraoui-15.3/src/hobix/bmemory.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobix.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixAST.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/hobix/bmemory.mli
flap-uzenat-elouraoui-15.3/src/hobix/hobixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixLexer.mll
flap-uzenat-elouraoui-15.3/src/hobix/hobixInitialization.ml
flap-uzenat-elouraoui-15.3/src/hobix/hopixToHobix.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixParser.mly
flap-uzenat-elouraoui-15.3/src/hobix/hobixTypes.ml
flap-uzenat-elouraoui-15.3/src/flap.ml
flap-uzenat-elouraoui-15.3/src/mips/
flap-uzenat-elouraoui-15.3/src/mips/mipsArch.ml
flap-uzenat-elouraoui-15.3/src/mips/mips.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsInitialization.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsInterpreter.ml
flap-uzenat-elouraoui-15.3/src/mips/retrolixToMips.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsTypechecker.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsAST.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsLexer.mll
flap-uzenat-elouraoui-15.3/src/mips/mipsParser.mly
flap-uzenat-elouraoui-15.3/src/utilities/
flap-uzenat-elouraoui-15.3/src/utilities/userInput.ml
flap-uzenat-elouraoui-15.3/src/utilities/listMonad.ml
flap-uzenat-elouraoui-15.3/src/utilities/position.ml
flap-uzenat-elouraoui-15.3/src/utilities/dict.mli
flap-uzenat-elouraoui-15.3/src/utilities/error.ml
flap-uzenat-elouraoui-15.3/src/utilities/syntacticAnalysis.ml
flap-uzenat-elouraoui-15.3/src/utilities/position.mli
flap-uzenat-elouraoui-15.3/src/utilities/error.mli
flap-uzenat-elouraoui-15.3/src/utilities/listMonad.mli
flap-uzenat-elouraoui-15.3/src/utilities/extPPrint.ml
flap-uzenat-elouraoui-15.3/src/utilities/int16.ml
flap-uzenat-elouraoui-15.3/src/utilities/syntacticAnalysis.mli
flap-uzenat-elouraoui-15.3/src/utilities/stdUserInput.ml
flap-uzenat-elouraoui-15.3/src/utilities/option.ml
flap-uzenat-elouraoui-15.3/src/utilities/extStd.ml
flap-uzenat-elouraoui-15.3/src/utilities/dict.ml
flap-uzenat-elouraoui-15.3/src/utilities/int16.mli
flap-uzenat-elouraoui-15.3/src/commandLineOptions.ml
flap-uzenat-elouraoui-15.3/_tags
flap-uzenat-elouraoui-15.3/Makefile.generic
flap-uzenat-elouraoui-15.3/Makefile.config
flap-uzenat-elouraoui-15.3/Makefile
=> Je compile.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
ocamlfind ocamldep -package unix -package str -modules src/flap.ml > src/flap.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/commandLineOptions.ml > src/commandLineOptions.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/options.ml > src/options.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.mli > src/utilities/error.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.mli > src/utilities/position.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/position.cmi src/utilities/position.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/error.cmi src/utilities/error.mli
ocamlfind ocamldep -package unix -package str -modules src/version.ml > src/version.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/options.cmo src/options.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/version.cmo src/version.ml
ocamlfind ocamldep -package unix -package str -modules src/common/compilers.ml > src/common/compilers.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extStd.ml > src/utilities/extStd.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/common/languages.ml > src/common/languages.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extStd.cmo src/utilities/extStd.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/languages.cmo src/common/languages.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixInitialization.ml > src/fopix/fopixInitialization.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/compilers.cmo src/common/compilers.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopix.ml > src/fopix/fopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixAST.ml > src/fopix/fopixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixInterpreter.ml > src/fopix/fopixInterpreter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/bmemory.mli > src/hobix/bmemory.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixAST.cmo src/fopix/fopixAST.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/bmemory.cmi src/hobix/bmemory.mli
/usr/bin/ocamllex -q src/fopix/fopixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixLexer.ml > src/fopix/fopixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/fopix/fopixParser.mly > src/fopix/fopixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/fopix/fopixParser.mly
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixParser.mli > src/fopix/fopixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixParser.cmi src/fopix/fopixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixPrettyPrinter.ml > src/fopix/fopixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrint.ml > src/lib/pprint/PPrint.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.mli > src/lib/pprint/PPrintCombinators.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.mli > src/lib/pprint/PPrintEngine.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintRenderer.ml > src/lib/pprint/PPrintRenderer.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintRenderer.cmo src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintEngine.cmi src/lib/pprint/PPrintEngine.mli
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.mli > src/lib/pprint/PPrintOCaml.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintCombinators.cmi src/lib/pprint/PPrintCombinators.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintOCaml.cmi src/lib/pprint/PPrintOCaml.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrint.cmo src/lib/pprint/PPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixTypechecker.ml > src/fopix/fopixTypechecker.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.mli > src/utilities/syntacticAnalysis.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmo src/fopix/fopixInterpreter.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmo src/fopix/fopixInterpreter.ml
File "src/fopix/fopixInterpreter.ml", line 180, characters 25-1160:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
UnknownFunCall (_, _)
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixLexer.cmo src/fopix/fopixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixPrettyPrinter.cmo src/fopix/fopixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixTypechecker.cmo src/fopix/fopixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmi src/utilities/syntacticAnalysis.mli
ocamlfind ocamldep -package unix -package str -modules src/fopix/hobixToFopix.ml > src/fopix/hobixToFopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/dict.mli > src/utilities/dict.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopix.cmo src/fopix/fopix.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobix.ml > src/hobix/hobix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixAST.ml > src/hobix/hobixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixInterpreter.ml > src/hobix/hobixInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixAST.cmo src/hobix/hobixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixPrettyPrinter.ml > src/hobix/hobixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extPPrint.ml > src/utilities/extPPrint.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extPPrint.cmo src/utilities/extPPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixTypechecker.ml > src/hobix/hobixTypechecker.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixAST.ml > src/hopix/hopixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/listMonad.mli > src/utilities/listMonad.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/listMonad.cmi src/utilities/listMonad.mli
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixPrettyPrinter.ml > src/hopix/hopixPrettyPrinter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixAST.cmo src/hopix/hopixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypes.ml > src/hopix/hopixTypes.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/dict.cmi src/utilities/dict.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmo src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypes.cmo src/hopix/hopixTypes.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInterpreter.cmo src/hobix/hobixInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixPrettyPrinter.cmo src/hobix/hobixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixTypechecker.cmo src/hobix/hobixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobix.cmo src/hobix/hobix.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/hobixToFopix.cmo src/fopix/hobixToFopix.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixInitialization.ml > src/hobix/hobixInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/hopixToHobix.ml > src/hobix/hopixToHobix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopix.ml > src/hopix/hopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInterpreter.ml > src/hopix/hopixInterpreter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.mli > src/hopix/memory.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/memory.cmi src/hopix/memory.mli
/usr/bin/ocamllex -q src/hopix/hopixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixLexer.ml > src/hopix/hopixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/hopix/hopixParser.mly > src/hopix/hopixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/hopix/hopixParser.mly
+ menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/hopix/hopixParser.mly
File "src/hopix/hopixParser.mly", line 44, characters 0-5:
Warning: the precedence level assigned to SHARP is never useful.
Warning: one state has shift/reduce conflicts.
Warning: one shift/reduce conflict was arbitrarily resolved.
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.mli > src/hopix/hopixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixParser.cmi src/hopix/hopixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypechecker.ml > src/hopix/hopixTypechecker.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInterpreter.cmo src/hopix/hopixInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixLexer.cmo src/hopix/hopixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypechecker.cmo src/hopix/hopixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopix.cmo src/hopix/hopix.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hopixToHobix.cmo src/hobix/hopixToHobix.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInitialization.ml > src/hopix/hopixInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsInitialization.ml > src/mips/mipsInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mips.ml > src/mips/mips.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsAST.ml > src/mips/mipsAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/int16.mli > src/utilities/int16.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsArch.ml > src/mips/mipsArch.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/int16.cmi src/utilities/int16.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsArch.cmo src/mips/mipsArch.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsInterpreter.ml > src/mips/mipsInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsAST.cmo src/mips/mipsAST.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsPrettyPrinter.ml > src/mips/mipsPrettyPrinter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsPrettyPrinter.cmo src/mips/mipsPrettyPrinter.ml
/usr/bin/ocamllex -q src/mips/mipsLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsLexer.ml > src/mips/mipsLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/mips/mipsParser.mly > src/mips/mipsParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/mips/mipsParser.mly
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsParser.mli > src/mips/mipsParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsParser.cmi src/mips/mipsParser.mli
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsTypechecker.ml > src/mips/mipsTypechecker.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInterpreter.cmo src/mips/mipsInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsLexer.cmo src/mips/mipsLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsTypechecker.cmo src/mips/mipsTypechecker.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/retrolixToMips.ml > src/mips/retrolixToMips.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mips.cmo src/mips/mips.ml
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolix.ml > src/retrolix/retrolix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixAST.ml > src/retrolix/retrolixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixInterpreter.ml > src/retrolix/retrolixInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixAST.cmo src/retrolix/retrolixAST.ml
/usr/bin/ocamllex -q src/retrolix/retrolixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixLexer.ml > src/retrolix/retrolixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/retrolix/retrolixParser.mly > src/retrolix/retrolixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/retrolix/retrolixParser.mly
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixParser.mli > src/retrolix/retrolixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixParser.cmi src/retrolix/retrolixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixPrettyPrinter.ml > src/retrolix/retrolixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixTypechecker.ml > src/retrolix/retrolixTypechecker.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInterpreter.cmo src/retrolix/retrolixInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixLexer.cmo src/retrolix/retrolixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmo src/retrolix/retrolixPrettyPrinter.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmo src/retrolix/retrolixPrettyPrinter.ml
File "src/retrolix/retrolixPrettyPrinter.ml", line 105, characters 14-113:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(LBool _|LChar _|LString _)
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixTypechecker.cmo src/retrolix/retrolixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolix.cmo src/retrolix/retrolix.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmo src/mips/retrolixToMips.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmo src/mips/retrolixToMips.ml
File "src/mips/retrolixToMips.ml", line 86, characters 4-536:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
`Immediate (LBool _|LChar _|LString _)
File "src/mips/retrolixToMips.ml", line 27, characters 10-15:
Warning 26: unused variable block.
File "src/mips/retrolixToMips.ml", line 39, characters 6-17:
Warning 26: unused variable instruction.
File "src/mips/retrolixToMips.ml", line 42, characters 6-10:
Warning 26: unused variable call.
File "src/mips/retrolixToMips.ml", line 45, characters 6-20:
Warning 26: unused variable load_immediate.
File "src/mips/retrolixToMips.ml", line 50, characters 6-10:
Warning 26: unused variable tmp1.
File "src/mips/retrolixToMips.ml", line 51, characters 6-10:
Warning 26: unused variable tmp2.
File "src/mips/retrolixToMips.ml", line 55, characters 6-14:
Warning 26: unused variable register.
File "src/mips/retrolixToMips.ml", line 69, characters 6-18:
Warning 26: unused variable mk_operation.
File "src/mips/retrolixToMips.ml", line 85, characters 6-17:
Warning 26: unused variable load_rvalue.
File "src/mips/retrolixToMips.ml", line 106, characters 6-22:
Warning 26: unused variable variable_address.
File "src/mips/retrolixToMips.ml", line 111, characters 6-19:
Warning 26: unused variable load_variable.
File "src/mips/retrolixToMips.ml", line 124, characters 6-20:
Warning 26: unused variable store_variable.
File "src/mips/retrolixToMips.ml", line 136, characters 6-25:
Warning 26: unused variable function_definition.
File "src/mips/retrolixToMips.ml", line 142, characters 6-26:
Warning 26: unused variable allocate_stack_frame.
File "src/mips/retrolixToMips.ml", line 147, characters 6-22:
Warning 26: unused variable free_stack_frame.
File "src/mips/retrolixToMips.ml", line 106, characters 37-52:
Warning 26: unused variable x.
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixInitialization.ml > src/retrolix/retrolixInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/fopixToRetrolix.ml > src/retrolix/fopixToRetrolix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixRegisterAllocation.ml > src/retrolix/retrolixRegisterAllocation.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/graphColoring.ml > src/retrolix/graphColoring.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/graph.mli > src/retrolix/graph.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/option.ml > src/utilities/option.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graph.cmi src/retrolix/graph.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/option.cmo src/utilities/option.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmo src/retrolix/graphColoring.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmo src/retrolix/graphColoring.ml
File "src/retrolix/graphColoring.ml", line 194, characters 6-17:
Warning 21: this statement never returns (or has an unsound type.)
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixRegisterAllocation.cmo src/retrolix/retrolixRegisterAllocation.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/fopixToRetrolix.cmo src/retrolix/fopixToRetrolix.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/userInput.ml > src/utilities/userInput.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/stdUserInput.ml > src/utilities/stdUserInput.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/stdUserInput.cmo src/utilities/stdUserInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/commandLineOptions.cmo src/commandLineOptions.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInitialization.cmo src/fopix/fopixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInitialization.cmo src/hobix/hobixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInitialization.cmo src/hopix/hopixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInitialization.cmo src/mips/mipsInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInitialization.cmo src/retrolix/retrolixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/userInput.cmo src/utilities/userInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/flap.cmo src/flap.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.ml > src/utilities/error.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.ml > src/utilities/position.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/position.cmx src/utilities/position.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/error.cmx src/utilities/error.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/options.cmx src/options.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/version.cmx src/version.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extStd.cmx src/utilities/extStd.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/languages.cmx src/common/languages.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/compilers.cmx src/common/compilers.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/bmemory.ml > src/hobix/bmemory.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixAST.cmx src/fopix/fopixAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/bmemory.cmx src/hobix/bmemory.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixParser.ml > src/fopix/fopixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixParser.cmx src/fopix/fopixParser.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.ml > src/lib/pprint/PPrintCombinators.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.ml > src/lib/pprint/PPrintEngine.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintEngine.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.ml > src/lib/pprint/PPrintOCaml.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintCombinators.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrintOCaml.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrint.cmx src/lib/pprint/PPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.ml > src/utilities/syntacticAnalysis.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmx src/fopix/fopixInterpreter.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmx src/fopix/fopixInterpreter.ml
File "src/fopix/fopixInterpreter.ml", line 180, characters 25-1160:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
UnknownFunCall (_, _)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixLexer.cmx src/fopix/fopixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixPrettyPrinter.cmx src/fopix/fopixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixTypechecker.cmx src/fopix/fopixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmx src/utilities/syntacticAnalysis.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/dict.ml > src/utilities/dict.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopix.cmx src/fopix/fopix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixAST.cmx src/hobix/hobixAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extPPrint.cmx src/utilities/extPPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/listMonad.ml > src/utilities/listMonad.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/listMonad.cmx src/utilities/listMonad.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixAST.cmx src/hopix/hopixAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/dict.cmx src/utilities/dict.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmx src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypes.cmx src/hopix/hopixTypes.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInterpreter.cmx src/hobix/hobixInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixPrettyPrinter.cmx src/hobix/hobixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixTypechecker.cmx src/hobix/hobixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobix.cmx src/hobix/hobix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/hobixToFopix.cmx src/fopix/hobixToFopix.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.ml > src/hopix/memory.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/memory.cmx src/hopix/memory.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.ml > src/hopix/hopixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixParser.cmx src/hopix/hopixParser.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInterpreter.cmx src/hopix/hopixInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixLexer.cmx src/hopix/hopixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypechecker.cmx src/hopix/hopixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopix.cmx src/hopix/hopix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hopixToHobix.cmx src/hobix/hopixToHobix.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/int16.ml > src/utilities/int16.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/int16.cmx src/utilities/int16.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/int16.cmx src/utilities/int16.ml
File "src/utilities/int16.ml", line 20, characters 2-19:
Warning 21: this statement never returns (or has an unsound type.)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsArch.cmx src/mips/mipsArch.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsAST.cmx src/mips/mipsAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsPrettyPrinter.cmx src/mips/mipsPrettyPrinter.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsParser.ml > src/mips/mipsParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsParser.cmx src/mips/mipsParser.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInterpreter.cmx src/mips/mipsInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsLexer.cmx src/mips/mipsLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsTypechecker.cmx src/mips/mipsTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mips.cmx src/mips/mips.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixAST.cmx src/retrolix/retrolixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixParser.ml > src/retrolix/retrolixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixParser.cmx src/retrolix/retrolixParser.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInterpreter.cmx src/retrolix/retrolixInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixLexer.cmx src/retrolix/retrolixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmx src/retrolix/retrolixPrettyPrinter.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmx src/retrolix/retrolixPrettyPrinter.ml
File "src/retrolix/retrolixPrettyPrinter.ml", line 105, characters 14-113:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(LBool _|LChar _|LString _)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixTypechecker.cmx src/retrolix/retrolixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolix.cmx src/retrolix/retrolix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmx src/mips/retrolixToMips.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmx src/mips/retrolixToMips.ml
File "src/mips/retrolixToMips.ml", line 86, characters 4-536:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
`Immediate (LBool _|LChar _|LString _)
File "src/mips/retrolixToMips.ml", line 27, characters 10-15:
Warning 26: unused variable block.
File "src/mips/retrolixToMips.ml", line 39, characters 6-17:
Warning 26: unused variable instruction.
File "src/mips/retrolixToMips.ml", line 42, characters 6-10:
Warning 26: unused variable call.
File "src/mips/retrolixToMips.ml", line 45, characters 6-20:
Warning 26: unused variable load_immediate.
File "src/mips/retrolixToMips.ml", line 50, characters 6-10:
Warning 26: unused variable tmp1.
File "src/mips/retrolixToMips.ml", line 51, characters 6-10:
Warning 26: unused variable tmp2.
File "src/mips/retrolixToMips.ml", line 55, characters 6-14:
Warning 26: unused variable register.
File "src/mips/retrolixToMips.ml", line 69, characters 6-18:
Warning 26: unused variable mk_operation.
File "src/mips/retrolixToMips.ml", line 85, characters 6-17:
Warning 26: unused variable load_rvalue.
File "src/mips/retrolixToMips.ml", line 106, characters 6-22:
Warning 26: unused variable variable_address.
File "src/mips/retrolixToMips.ml", line 111, characters 6-19:
Warning 26: unused variable load_variable.
File "src/mips/retrolixToMips.ml", line 124, characters 6-20:
Warning 26: unused variable store_variable.
File "src/mips/retrolixToMips.ml", line 136, characters 6-25:
Warning 26: unused variable function_definition.
File "src/mips/retrolixToMips.ml", line 142, characters 6-26:
Warning 26: unused variable allocate_stack_frame.
File "src/mips/retrolixToMips.ml", line 147, characters 6-22:
Warning 26: unused variable free_stack_frame.
File "src/mips/retrolixToMips.ml", line 106, characters 37-52:
Warning 26: unused variable x.
ocamlfind ocamldep -package unix -package str -modules src/retrolix/graph.ml > src/retrolix/graph.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graph.cmx src/retrolix/graph.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/option.cmx src/utilities/option.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmx src/retrolix/graphColoring.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmx src/retrolix/graphColoring.ml
File "src/retrolix/graphColoring.ml", line 194, characters 6-17:
Warning 21: this statement never returns (or has an unsound type.)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixRegisterAllocation.cmx src/retrolix/retrolixRegisterAllocation.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/fopixToRetrolix.cmx src/retrolix/fopixToRetrolix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/stdUserInput.cmx src/utilities/stdUserInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/commandLineOptions.cmx src/commandLineOptions.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInitialization.cmx src/fopix/fopixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInitialization.cmx src/hobix/hobixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInitialization.cmx src/hopix/hopixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInitialization.cmx src/mips/mipsInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInitialization.cmx src/retrolix/retrolixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/userInput.cmx src/utilities/userInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/flap.cmx src/flap.ml
ocamlfind ocamlopt -linkpkg -package unix -package str src/utilities/position.cmx src/utilities/error.cmx src/options.cmx src/version.cmx src/commandLineOptions.cmx src/common/languages.cmx src/utilities/extStd.cmx src/common/compilers.cmx src/fopix/fopixAST.cmx src/hobix/bmemory.cmx src/fopix/fopixInterpreter.cmx src/fopix/fopixParser.cmx src/fopix/fopixLexer.cmx src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrint.cmx src/fopix/fopixPrettyPrinter.cmx src/fopix/fopixTypechecker.cmx src/utilities/syntacticAnalysis.cmx src/fopix/fopix.cmx src/hobix/hobixAST.cmx src/hobix/hobixInterpreter.cmx src/utilities/extPPrint.cmx src/hobix/hobixPrettyPrinter.cmx src/utilities/listMonad.cmx src/hopix/hopixAST.cmx src/hopix/hopixPrettyPrinter.cmx src/utilities/dict.cmx src/hopix/hopixTypes.cmx src/hobix/hobixTypechecker.cmx src/hobix/hobix.cmx src/fopix/hobixToFopix.cmx src/fopix/fopixInitialization.cmx src/hopix/memory.c
ln -s flap.native flap
=> Je lance les tests.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make -C tests check
make[1]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests'
make -C ..
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3'
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/bad'
========================================================
In infersimpletypes/bad
GOOD: 0 / 0
[XFAIL]  apply2.hopix

INPUT: 
val f x y := 2 * x + y.
val y := f 0 true.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  apply3.hopix

INPUT: 
val f x y := 2 * x + y.
val h := f 0.
val y := h 1 2.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  apply4.hopix

INPUT: 
val apply (f : int -> int) x := f x 0.
val x := apply (\x => x) 0.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  apply.hopix

INPUT: 
val f x := 2 * x + 1.
val y := f 'a'.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  boolvar.hopix

INPUT: 
val b : string := true.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case10.hopix

INPUT: 
type r := { x : int }.
type a := { A : r }.

val get a := a ? { A ({ x = 0 }) => 1 | A ({ x = z }) => x }.
OUTPUT: 
Line 4, characters 57-58: Error (typechecking)
  Unbound identifier `x'.
--------------------------------------------------------
[XFAIL]  case2.hopix

INPUT: 
type l := { N | C : int * l }.
rec len x := x ? {
    | N => 0
    | C xs => 1 + len xs
}.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  case3.hopix

INPUT: 
val f (x : char) := x ? { (y : int) => y }.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case4.hopix

INPUT: 
val fint x := x ? { 42 => 0 | _ => 1 }.
val fbool x := x ? { true => 0 | 0 => 1 }.
val fchar x := x ? { 'a' => 0 | _ => 1 }.
val fstring x := x ? { "Luke" => 0 | _ => 1 }.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case5.hopix

INPUT: 
type p := { x : int; y : int }.

val projx p := p ? { { x = z; y = u } => z }.
val projy p := p ? { { x = z; u = y } => u }.
OUTPUT: 
Fatal error: exception Not_found
--------------------------------------------------------
[XFAIL]  case6.hopix

INPUT: 
type o := { None | Some : int }.

val complete o := o ? { Some & x => x | _ => Some (0) }.
OUTPUT: 
Fatal error: exception Invalid_argument("List.fold_left2")
--------------------------------------------------------
[XFAIL]  case7.hopix

INPUT: 
type t := { A : int | B : int }.

val f x := x ? { A (x) | B (x) => z }.
OUTPUT: 
Fatal error: exception Failure("not ground ")
--------------------------------------------------------
[XFAIL]  case8.hopix

INPUT: 
type t := { L : int | B : t * t }.

val max x y :=
 if x > y then x else y fi.

rec depth t := t ? {
  | L (x) => 1
  | B (a, b) => max a b
}.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case9.hopix

INPUT: 
type t := { L : int | B : t * t }.

rec leaf t :=
    t ? {
    | L (x) | B (L (x), _) | B (_) => x
    }.

OUTPUT: 
Fatal error: exception Invalid_argument("List.fold_left2")
--------------------------------------------------------
[XFAIL]  case.hopix

INPUT: 
type t := { A | B }.
val f x := x ? { A => 0 | B => "Larzac" }.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  charvar.hopix

INPUT: 
val c : bool := 'a'.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  fun2.hopix

INPUT: 
val f :=
  val y := 0;
  \(x : char) => y + x.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  fun3.hopix

INPUT: 
val f :=
  val y := 0;
  \x => (\z => u + x) y.
OUTPUT: 
Line 3, characters 15-16: Error (typechecking)
  Unbound identifier `u'.
--------------------------------------------------------
[XFAIL]  fun4.hopix

INPUT: 
val g := \x (y : int -> int) (z : int -> int) =>
    ((x y (y z (z 0) : int -> int)) : int -> int -> int).

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  fun5.hopix

INPUT: 
rec omega f (x : int) : int := f (omega f) x.
val fact := omega (\fact n => if n = 0 then 1 else n * fact (n - 1) fi).
val z := fact 5 32.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  fun.hopix

INPUT: 
val f : int := \x => x + 1.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  ifthenelse.hopix

INPUT: 
val f x y :=
    if x then 1 else if y then 2 else "Larzac" fi fi.

val x := f true true.
val y := f false false.
val z := f false true.
val t := f true false.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  intvar.hopix

INPUT: 
val x : char := 1.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  iszero.hopix

INPUT: 
val iszero := \(x : int) => (x = "zero?").

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  lazy.hopix

INPUT: 
type int_computation := {
  | Todo : int -> int
  | Done : int
}.

type lazy_int := { cell : int_computation }.

val lazy e := { cell := Todo (e) }.

val force ({ cell = x } & l) := x ? {
    | Todo (compute) =>
      val y := compute 0;
      val u := l#cell <- Done (y);
      y
    | Done (y) =>
      y
}.

type ref_int := { content : int }.

val xr := { content := 0 }.
val lz := lazy (\x => val u := xr#content <- "Larzac"; 1).
val y := xr#content.
val z :=
  val u := force lz;
  xr#content.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  listmonad.hopix

INPUT: 
type list := { Nil | Cons : int * list }.

rec append l1 l2 :=
  l1 ? { Nil => l2 | Cons (x, xs) => Cons (x, append xs l2) }.

rec flatmap f l :=
   l ? {
   | Nil => Nil
   | Cons (x, xs) => append (f x) (flatmap f xs)
   }.

val return x := Cons (x, Nil).
val bind x f := flatmap f x.
val fail := Nil.
val return_if what condition :=
  if condition (what) then return what else fail fi.

rec range start stop :=
  if start > stop then Nil else Cons (start, range (start + 1) stop) fi.

val all_sum start stop :=
  bind (range start stop) (\x =>
  bind (range start stop) (\y =>
    return_if (x + y) (\z => z = 10 && x > y)
  )).

rec len l :=
  l ? { Nil => 0 | Cons (_, xs) => 1 + len xs }.

val tens := len (all_sum 0).
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  localdefine2.hopix

INPUT: 
val x :=
    val y : string := 42;
    y.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  localdefine.hopix

INPUT: 
val x : string :=
    val y := 42;
    y.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  localrecs.hopix

INPUT: 
val test :=
  val not b := if b then false else true fi;
  rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
  and odd x := not (even (x));
  val ahah := even 42;
  val ohoh := 1 + even 43;
  ahah || ohoh.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  record2.hopix

INPUT: 
type p := { x : int; y : int }.

val projx p := p#x.

val projy p := p#z.
OUTPUT: 
Fatal error: exception Assert_failure("src/hopix/hopixTypechecker.ml", 1046, 16)
--------------------------------------------------------
[XFAIL]  record3.hopix

INPUT: 
type p := { x : int; y : int }.

val updatex p x := p#x <- x.
val updatey (p : int) y := p#y <- y.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  record.hopix

INPUT: 
type p := { x : int; y : int }.

val make x y := { x := x; z := y }.
OUTPUT: 
Fatal error: exception Assert_failure("src/hopix/hopixTypechecker.ml", 1041, 16)
--------------------------------------------------------
[XFAIL]  recs2.hopix

INPUT: 
val not b := if b then false else true fi.
rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
and odd x := 0 - even (x).
val ahah := even 42.
val ohoh := even 43.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs3.hopix

INPUT: 
rec f (x : string) : int := f (x + 0).

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs4.hopix

INPUT: 
rec f (x : int) : int := f true.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs5.hopix

INPUT: 
rec f (g : int -> int) x : int := f g (g x 0).

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs6.hopix

INPUT: 
rec f (x : int)  := g 0
and g (x : char) := 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs7.hopix

INPUT: 
rec f x : int := g x
and g x := h x
and h x := i x
and i x := f (x + 1) 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs.hopix

INPUT: 
rec f x := g (x + 0)
and g (x : bool) := 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  stringvar2.hopix

INPUT: 
val s := "Hello Hopix!".
val f x : int :=
  val id x := x;
  val z := id s;
  id x.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  stringvar.hopix

INPUT: 
val s : int := "Hello Hopix!".

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  tagged.hopix

INPUT: 
type t := { A }.
val x := A.
val y := B.
OUTPUT: 
Fatal error: exception Failure("impossible")
--------------------------------------------------------
[XFAIL]  varrecord.hopix

INPUT: 
val x := 1.
type p := { x : char }.
val p := ({ x := 'a' })#y.
OUTPUT: 
Fatal error: exception Assert_failure("src/hopix/hopixTypechecker.ml", 1046, 16)
--------------------------------------------------------
[XFAIL]  varvar2.hopix

INPUT: 
val x := 1.
val y :=
  val x := 'a';
  z.
OUTPUT: 
Fatal error: exception Failure("not ground ")
--------------------------------------------------------
[XFAIL]  varvar3.hopix

INPUT: 
val x := 'a'.
val f y := x + 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  varvar.hopix

INPUT: 
val y := x.
OUTPUT: 
Fatal error: exception Failure("not ground ")
--------------------------------------------------------
./apply2.hopix ./apply3.hopix ./apply4.hopix ./apply.hopix ./boolvar.hopix ./case10.hopix ./case2.hopix ./case3.hopix ./case4.hopix ./case5.hopix ./case6.hopix ./case7.hopix ./case8.hopix ./case9.hopix ./case.hopix ./charvar.hopix ./fun2.hopix ./fun3.hopix ./fun4.hopix ./fun5.hopix ./fun.hopix ./ifthenelse.hopix ./intvar.hopix ./iszero.hopix ./lazy.hopix ./listmonad.hopix ./localdefine2.hopix ./localdefine.hopix ./localrecs.hopix ./record2.hopix ./record3.hopix ./record.hopix ./recs2.hopix ./recs3.hopix ./recs4.hopix ./recs5.hopix ./recs6.hopix ./recs7.hopix ./recs.hopix ./stringvar2.hopix ./stringvar.hopix ./tagged.hopix ./varrecord.hopix ./varvar2.hopix ./varvar3.hopix ./varvar.hopix
BAD:  46 / 46
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/bad'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/bad'
========================================================
In simpletypes/bad
GOOD: 0 / 0
[XFAIL]  checkapply2.hopix

INPUT: 
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> int).
val y := (f 0 1 : char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkapply3.hopix

INPUT: 
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> string).
val h := (f 0 : int -> int).
val y := (h 1 : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkapply4.hopix

INPUT: 
val apply :=
  (\((f : int -> int) : int -> int) =>
    (\(x : int) => (f x : int) : int -> int)
  : (int -> int) -> int -> int).
val x := (apply (\(x : int) => (x : bool)) 0 : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkapply.hopix

INPUT: 
val f := (\(x : int) => (`* 2 x : int) : int -> int).
val y := (f 0 : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkboolvar.hopix

INPUT: 
val b := (0 : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase10.hopix

INPUT: 
type r := { x : int }.
type a := { A : t }.
val get :=
  (\(a : a) =>
    ((a : a) ? { | A ({ x = 0 }) => 1 | A ({ x = (x : int) }) => x }
    : int)
  : a -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase2.hopix

INPUT: 
type l := { N | C : l * int }.
rec
 len :=
  (\(x : l) =>
    ((x : l) ? { | N => 0 | C (_, (xs : l)) => `+ 1 (len xs) }
    : int)
  : l -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase3.hopix

INPUT: 
val f :=
  (\(x : char) => ((x : int) ? { | ((y : int) : int) => y } : int)
  : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase4.hopix

INPUT: 
val fint :=
  (\(x : int) => ((x : int) ? { | 42 => 0 | _ => 1 } : int)
  : int -> int).
val fbool :=
  (\(x : bool) =>
    ((x : bool) ? { | true => 0 | false => 1 } : int)
  : bool -> int).
val fchar :=
  (\(x : bool) => ((x : char) ? { | 'a' => 0 | _ => 1 } : int)
  : char -> int).
val fstring :=
  (\(x : string) =>
    ((x : string) ? { | "Luke" => 0 | _ => 1 } : int)
  : string -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase5.hopix

INPUT: 
type p := { x : int ; y : bool }.
val projx :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => z } : int)
  : p -> int).
val projy :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => u } : int)
  : p -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase6.hopix

INPUT: 
type o := { None | Some : char }.
val complete :=
  (\(o : o) =>
    ((o : o) ? { | (Some (_) & (x : o)) => x | _ => Some (0) } : o)
  : o -> o).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase7.hopix

INPUT: 
type t := { A : int | B : char }.
val f :=
  (\(x : t) =>
    ((x : t) ? { | (A ((x : int)) | B ((x : int))) => x } : int)
  : t -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase8.hopix

INPUT: 
type t := { L : int | B : t * t }.
val max :=
  (\(x : int) =>
    (\(y : int) => (if `> x y then x else x fi : int) : int -> int)
  : int -> int -> int).
rec
 depth :=
  (\(t : t) =>
    ((t : t) ?
    {
    | L ((x : char)) => 1
    | B ((a : t), (b : t)) => max (depth a) (depth b)
    }
    : int)
  : t -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase9.hopix

INPUT: 
type t := { L : int | B : t }.
rec
 leaf :=
  (\(t : t) =>
    ((t : t) ?
    {
    |
      (L
      ((x
      :
      int))
      |
      B
      (L
      ((x
      :
      int)),
      _)
      |
      B
      (_,
      L
      ((x
      :
      int))))
      =>
      x
    | B ((a : t), (b : t)) => leaf a
    }
    : int)
  : t -> int).


OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase.hopix

INPUT: 
type t := { A | B }.
val f :=
  (\(x : t) => ((x : t) ? { | A => 0 | B => 1 } : bool) : t -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcharvar.hopix

INPUT: 
val c := ('a' : string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun2.hopix

INPUT: 
val f :=
  (val y := (0 : int); \(x : int) => (`+ y x : bool) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun3.hopix

INPUT: 
val f :=
  (val y := (0 : int);
  \(x : int) => ((\(z : int) => (`+ y x : int)) y : int)
  : int -> int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun4.hopix

INPUT: 
val g :=
  (\(x : ((int -> int) -> int -> int) -> int -> int) =>
    (\(y : (int -> int) -> int -> int) =>
      (\((z : int -> int) : int -> int) =>
        ((x y ((y z (z 0) : int)) : bool) : int)
      : (int -> int) -> int)
    : ((int -> int) -> int -> int) -> (int -> int) -> int)
  :
  (((int -> int) -> int -> int) -> int -> int)
  ->
  ((int -> int) -> int -> int) -> (int -> int) -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun5.hopix

INPUT: 
rec
 omega :=
  (\(f : (int -> int) -> int -> int) =>
    (\((x : int) : int) => ((f (omega f) x : int) : int)
    : int -> int)
  : ((int -> int) -> int -> int) -> int -> int).
val fact :=
  (omega
  (\(fact : int -> int) =>
    (\(n : int) => (if `= n 0 then 1 else 1 fi : int) : int -> char))
  : int -> int).
val z := (fact 5 : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun.hopix

INPUT: 
val f := (\(x : int) => (`+ x 1 : int) : int -> char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkifthenelse.hopix

INPUT: 
val f :=
  (\(x : bool) =>
    (\(y : bool) => (if x then 1 else 1 fi : int) : bool -> int)
  : bool -> bool -> bool).
val x := (f true true : int).
val y := (f false false : int).
val z := (f false true : int).
val t := (f true false : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkintvar.hopix

INPUT: 
val x := (1 : char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkiszero.hopix

INPUT: 
val iszero := (\(x : int) => (`= x 0 : bool) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklazy.hopix

INPUT: 
type int_computation := { Todo : int -> int | Done : int }.
type lazy_int := { cell : int_computation }.
val lazy :=
  (\(e : int -> int) => ({ cell := Todo (e) } : lazy_int)
  : (int -> int) -> lazy_int).
val force :=
  (\({ cell = (x : int_computation) } & (l : lazy_int)) =>
    ((x : int_computation) ?
    {
    | Todo ((compute : int -> int)) =>
      val y := (compute 0 : int);
      val u := (l#cell <- Done (y) : unit); y
    | Done ((y : int)) => y
    }
    : int)
  : lazy_int -> int).
type ref_int := { content : int }.
val xr := ({ content := 0 } : ref_int).
val lz :=
  (lazy
  (\(x : int) => (val u := (xr#content <- 42 : unit); 1 : int))
  : lazy_int).
val y := (xr#content : int).
val z := (val u := (force lz : int); xr : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklistmonad.hopix

INPUT: 
type list := { Nil | Cons : int * list }.
rec
 append :=
  (\(l1 : list) =>
    (\(l2 : list) =>
      ((l1 : list) ?
      {
      | Nil => l2
      | Cons ((x : int), (xs : list)) => Cons (x, append xs l2)
      }
      : list)
    : list -> list)
  : list -> list -> list).
rec
 flatmap :=
  (\(f : int -> list) =>
    (\(l : list) =>
      ((l : list) ?
      {
      | Nil => Nil
      | Cons ((x : int), (xs : list)) => append (f x) (flatmap f xs)
      }
      : list)
    : list -> list)
  : (int -> list) -> list -> list).
val return :=
  (\(x : int) => (Cons (x, Cons) : list) : int -> list).
val bind :=
  (\(x : list) =>
    (\(f : int -> list) => (flatmap f x : list)
    : (int -> list) -> list)
  : list -> (int -> list) -> list).
val fail := (Nil : list).
val return_if :=
  (\(what : int) =>
    (\(condition : int -> bool) =>
      (if condition what then return what else return what fi : list)
    : (int -> bool) -> list)
  : int -> (int -> bool) -> list).
rec
 range :=
  (\(start : int) =>
    (\(stop : int) => (if `> start stop then Nil else Nil fi : list)
    : int -> list)
  : int -> int -> list).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklocaldefine.hopix

INPUT: 
val x := (val y := ('a' : int); y : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklocalrecs.hopix

INPUT: 
val test :=
  (val not :=
      (\(b : bool) => (if b then false else false fi : bool)
      : bool -> bool);
  rec
     even :=
      (\(x : int) => (if `= x 'a' then true else true fi : bool)
      : int -> bool)
    and
     odd := (\(x : int) => (not (even x) : bool) : int -> bool);
  val ahah := (even 42 : bool);
  val ohoh := (even 43 : bool); ahah || ohoh
  : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecord2.hopix

INPUT: 
type p := { x : int ; y : int }.
val projx := (\(p : p) => (p#x : int) : p -> int).
val projy := (\(p : p) => (p#z : int) : p -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecord3.hopix

INPUT: 
type p := { x : int ; y : char }.
val updatex :=
  (\(p : p) => (\(x : int) => (p#x <- x : unit) : int -> unit)
  : p -> int -> unit).
val updatey :=
  (\(p : p) => (\(y : int) => (p#y <- y : unit) : int -> unit)
  : p -> int -> unit).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecord.hopix

INPUT: 
type p := { x : int ; z : int }.
val make :=
  (\(x : int) =>
    (\(y : int) => ({ x := x; y := y } : p) : int -> p)
  : int -> int -> p).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs2.hopix

INPUT: 
val not :=
  (\(b : bool) => (if b then false else false fi : bool)
  : bool -> int).
rec
 even :=
  (\(x : int) => (if `= x 0 then true else true fi : bool)
  : int -> bool)
and odd := (\(x : int) => (not (even x) : bool) : int -> bool).
val ahah := (even 42 : bool).
val ohoh := (even 43 : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs3.hopix

INPUT: 
rec
 f := (\(x : int) => ((f (`+ x 0) : int) : int) : int -> int -> char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs4.hopix

INPUT: 
rec
 f := (\((x : int) : bool) => ((f x : int) : int) : int -> int).


OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs5.hopix

INPUT: 
rec
 f :=
  (\((g : int -> int) : int -> int) =>
    (\(x : int) => ((f g (g x) : int) : int) : char -> int)
  : (int -> int) -> int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs6.hopix

INPUT: 
rec
 f :=
  (\((g : int -> int -> int) : int -> int) => (g 0 : int)
  : (int -> int -> int) -> int)
and g := (\((x : char) : char) => (0 : int) : char -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs7.hopix

INPUT: 
rec
 f := (\(x : int) => ((g x : int) : int) : int -> int)
and g := (\(x : int) => (h x : int) : int -> int)
and h := (\(x : int) => (i x : int) : int -> int)
and i := (\(x : int) => (f (`+ x 1) : int) : int -> bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs.hopix

INPUT: 
rec
 f := (\(x : int) => (g (`+ x 'a') : int) : int -> int)
and g := (\(x : int) => (0 : int) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkstringvar2.hopix

INPUT: 
val s := ("Hello Hopix!" : string).
val f :=
  (\(x : string) =>
    (val id := (\(x : string) => (x : string) : string -> string);
    val z := (id s : char); id x
    : string)
  : string -> string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkstringvar.hopix

INPUT: 
val s := ("Hello Hopix!" : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checktagged.hopix

INPUT: 
type t := { A | C }.
val x := (A : t).
val y := (B : t).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarrecord.hopix

INPUT: 
val x := (1 : int).
type p := { x : int }.
val p := (({ x := 'a' })#x : char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarvar2.hopix

INPUT: 
val x := (1 : int).
val y := (val x := ('a' : char); x : string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarvar3.hopix

INPUT: 
val x := ('a' : char).
val f := (\(x : unit) => (`+ x 0 : int) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarvar.hopix

INPUT: 
val x := (1 : int).
val y := (x : string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  intvar.hopix

INPUT: 
val x : int := 'a'.

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
./checkapply2.hopix ./checkapply3.hopix ./checkapply4.hopix ./checkapply.hopix ./checkboolvar.hopix ./checkcase10.hopix ./checkcase2.hopix ./checkcase3.hopix ./checkcase4.hopix ./checkcase5.hopix ./checkcase6.hopix ./checkcase7.hopix ./checkcase8.hopix ./checkcase9.hopix ./checkcase.hopix ./checkcharvar.hopix ./checkfun2.hopix ./checkfun3.hopix ./checkfun4.hopix ./checkfun5.hopix ./checkfun.hopix ./checkifthenelse.hopix ./checkintvar.hopix ./checkiszero.hopix ./checklazy.hopix ./checklistmonad.hopix ./checklocaldefine.hopix ./checklocalrecs.hopix ./checkrecord2.hopix ./checkrecord3.hopix ./checkrecord.hopix ./checkrecs2.hopix ./checkrecs3.hopix ./checkrecs4.hopix ./checkrecs5.hopix ./checkrecs6.hopix ./checkrecs7.hopix ./checkrecs.hopix ./checkstringvar2.hopix ./checkstringvar.hopix ./checktagged.hopix ./checkvarrecord.hopix ./checkvarvar2.hopix ./checkvarvar3.hopix ./checkvarvar.hopix ./intvar.hopix
BAD:  46 / 46
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/bad'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/good'
========================================================
In infersimpletypes/good
[ OK ]   apply2.hopix

INPUT:
val f x y := 2 * x + y.
val y := f 0 1.
OUTPUT: 
y : int
f : int -> int -> int
EXPECTED: 
y : int
f : int -> int -> int
--------------------------------------------------------
[ OK ]   apply3.hopix

INPUT:
val f x y := 2 * x + y.
val h := f 0.
val y := h 1.
OUTPUT: 
y : int
h : int -> int
f : int -> int -> int
EXPECTED: 
y : int
h : int -> int
f : int -> int -> int
--------------------------------------------------------
[ OK ]   apply4.hopix

INPUT:
val apply (f : int -> int) x := f x.
val x := apply (\x => x) 0.

OUTPUT: 
x : int
apply : (int -> int) -> int -> int
EXPECTED: 
x : int
apply : (int -> int) -> int -> int
--------------------------------------------------------
[ OK ]   apply.hopix

INPUT:
val f x := 2 * x.
val y := f 0.
OUTPUT: 
y : int
f : int -> int
EXPECTED: 
y : int
f : int -> int
--------------------------------------------------------
[ OK ]   boolvar.hopix

INPUT:
val b := true.

OUTPUT: 
b : bool
EXPECTED: 
b : bool
--------------------------------------------------------
[ OK ]   case10.hopix

INPUT:
type r := { x : int }.
type a := { A : r }.

val get a := a ? { A ({ x = 0 }) => 1 | A ({ x = x }) => x }.
OUTPUT: 
get : a -> int
EXPECTED: 
get : a -> int
--------------------------------------------------------
[ OK ]   case2.hopix

INPUT:
type l := { N | C : int * l }.
rec len x := x ? {
    | N => 0
    | C (_, xs) => 1 + len xs
}.
OUTPUT: 
len : l -> int
EXPECTED: 
len : l -> int
--------------------------------------------------------
[ OK ]   case3.hopix

INPUT:
val f x := x ? { (y : int) => y }.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   case4.hopix

INPUT:
val fint x := x ? { 42 => 0 | _ => 1 }.
val fbool x := x ? { true => 0 | false => 1 }.
val fchar x := x ? { 'a' => 0 | _ => 1 }.
val fstring x := x ? { "Luke" => 0 | _ => 1 }.
OUTPUT: 
fstring : string -> int
fchar : char -> int
fbool : bool -> int
fint : int -> int
EXPECTED: 
fstring : string -> int
fchar : char -> int
fbool : bool -> int
fint : int -> int
--------------------------------------------------------
[ OK ]   case5.hopix

INPUT:
type p := { x : int; y : int }.

val projx p := p ? { { x = z; y = u } => z }.
val projy p := p ? { { x = z; y = u } => u }.
OUTPUT: 
projy : p -> int
projx : p -> int
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ OK ]   case6.hopix

INPUT:
type o := { None | Some : int }.

val complete o := o ? { Some (_) & x => x | _ => Some (0) }.
OUTPUT: 
complete : o -> o
EXPECTED: 
complete : o -> o
--------------------------------------------------------
[ OK ]   case7.hopix

INPUT:
type t := { A : int | B : int }.

val f x := x ? { A (x) | B (x) => x }.
OUTPUT: 
f : t -> int
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ OK ]   case8.hopix

INPUT:
type t := { L : int | B : t * t }.

val max x y :=
 if x > y then x else y fi.

rec depth t := t ? {
  | L (x) => 1
  | B (a, b) => max (depth a) (depth b)
}.
OUTPUT: 
depth : t -> int
max : int -> int -> int
EXPECTED: 
depth : t -> int
max : int -> int -> int
--------------------------------------------------------
[ OK ]   case9.hopix

INPUT:
type t := { L : int | B : t * t }.

rec leaf t :=
    t ? {
    | L (x) | B (L (x), _) | B (_, L(x)) => x
    | B (a, b) => leaf a
    }.
OUTPUT: 
leaf : t -> int
EXPECTED: 
leaf : t -> int
--------------------------------------------------------
[ OK ]   case.hopix

INPUT:
type t := { A | B }.
val f x := x ? { A => 0 | B => 1 }.
OUTPUT: 
f : t -> int
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ OK ]   charvar.hopix

INPUT:
val c := 'a'.

OUTPUT: 
c : char
EXPECTED: 
c : char
--------------------------------------------------------
[ OK ]   fun2.hopix

INPUT:
val f :=
  val y := 0;
  \x => y + x.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   fun3.hopix

INPUT:
val f :=
  val y := 0;
  \x => (\z => y + x) y.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  fun4.hopix

INPUT:
val g := \x y (z : int -> int) =>
    ((x y (y z (z 0) : int)) : int).
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
g : (((int -> int) -> int -> int) -> int -> int)
->
((int -> int) -> int -> int) -> (int -> int) -> int
--------------------------------------------------------
[ OK ]   fun5.hopix

INPUT:
rec omega f (x : int) : int := f (omega f) x.
val fact := omega (\fact n => if n = 0 then 1 else n * fact (n - 1) fi).
val z := fact 5.
OUTPUT: 
z : int
fact : int -> int
omega : ((int -> int) -> int -> int) -> int -> int
EXPECTED: 
z : int
fact : int -> int
omega : ((int -> int) -> int -> int) -> int -> int
--------------------------------------------------------
[ OK ]   fun.hopix

INPUT:
val f := \x => x + 1.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   ifthenelse.hopix

INPUT:
val f x y :=
    if x then 1 else if y then 2 else 3 fi fi.

val x := f true true.
val y := f false false.
val z := f false true.
val t := f true false.
OUTPUT: 
t : int
z : int
y : int
x : int
f : bool -> bool -> int
EXPECTED: 
t : int
z : int
y : int
x : int
f : bool -> bool -> int
--------------------------------------------------------
[ OK ]   intvar.hopix

INPUT:
val x := 1.

OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   iszero.hopix

INPUT:
val iszero := \x => (x = 0).

OUTPUT: 
iszero : int -> bool
EXPECTED: 
iszero : int -> bool
--------------------------------------------------------
[ OK ]   lazy.hopix

INPUT:
type int_computation := {
  | Todo : int -> int
  | Done : int
}.

type lazy_int := { cell : int_computation }.

val lazy e := { cell := Todo (e) }.

val force ({ cell = x } & l) := x ? {
    | Todo (compute) =>
      val y := compute 0;
      val u := l#cell <- Done (y);
      y
    | Done (y) =>
      y
}.

type ref_int := { content : int }.

val xr := { content := 0 }.
val lz := lazy (\x => val u := xr#content <- 42; 1).
val y := xr#content.
val z :=
  val u := force lz;
  xr#content.

OUTPUT: 
z : int
y : int
lz : lazy_int
xr : ref_int
force : lazy_int -> int
lazy : (int -> int) -> lazy_int
EXPECTED: 
z : int
y : int
lz : lazy_int
xr : ref_int
force : lazy_int -> int
lazy : (int -> int) -> lazy_int
--------------------------------------------------------
[ OK ]   listmonad.hopix

INPUT:
type list := { Nil | Cons : int * list }.

rec append l1 l2 :=
  l1 ? { Nil => l2 | Cons (x, xs) => Cons (x, append xs l2) }.

rec flatmap f l :=
   l ? {
   | Nil => Nil
   | Cons (x, xs) => append (f x) (flatmap f xs)
   }.

val return x := Cons (x, Nil).
val bind x f := flatmap f x.
val fail := Nil.
val return_if what condition :=
  if condition (what) then return what else fail fi.

rec range start stop :=
  if start > stop then Nil else Cons (start, range (start + 1) stop) fi.

val all_sum start stop :=
  bind (range start stop) (\x =>
  bind (range start stop) (\y =>
    return_if (x + y) (\z => z = 10 && x > y)
  )).

rec len l :=
  l ? { Nil => 0 | Cons (_, xs) => 1 + len xs }.

val tens := len (all_sum 0 9).
OUTPUT: 
tens : int
len : list -> int
all_sum : int -> int -> list
range : int -> int -> list
return_if : int -> (int -> bool) -> list
fail : list
bind : list -> (int -> list) -> list
return : int -> list
flatmap : (int -> list) -> list -> list
append : list -> list -> list
EXPECTED: 
tens : int
len : list -> int
all_sum : int -> int -> list
range : int -> int -> list
return_if : int -> (int -> bool) -> list
fail : list
bind : list -> (int -> list) -> list
return : int -> list
flatmap : (int -> list) -> list -> list
append : list -> list -> list
--------------------------------------------------------
[ OK ]   localdefine.hopix

INPUT:
val x :=
    val y := 42;
    y.
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ KO ]   -->  localrecs.hopix

INPUT:
val test :=
  val not b := if b then false else true fi;
  rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
  and odd x := not (even (x));
  val ahah := even 42;
  val ohoh := even 43;
  ahah || ohoh.
OUTPUT: 
Fatal error: exception Failure("not ground ")
EXPECTED: 
test : bool
--------------------------------------------------------
[ OK ]   record2.hopix

INPUT:
type p := { x : int; y : int }.

val projx p := p#x.

val projy p := p#y.
OUTPUT: 
projy : p -> int
projx : p -> int
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ OK ]   record3.hopix

INPUT:
type p := { x : int; y : int }.

val updatex p x := p#x <- x.
val updatey p y := p#y <- y.
OUTPUT: 
updatey : p -> int -> unit
updatex : p -> int -> unit
EXPECTED: 
updatey : p -> int -> unit
updatex : p -> int -> unit
--------------------------------------------------------
[ OK ]   record.hopix

INPUT:
type p := { x : int; y : int }.

val make x y := { x := x; y := y }.
OUTPUT: 
make : int -> int -> p
EXPECTED: 
make : int -> int -> p
--------------------------------------------------------
[ OK ]   recs2.hopix

INPUT:
val not b := if b then false else true fi.
rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
and odd x := not (even (x)).
val ahah := even 42.
val ohoh := even 43.
OUTPUT: 
ohoh : bool
ahah : bool
odd : int -> bool
even : int -> bool
not : bool -> bool
EXPECTED: 
ohoh : bool
ahah : bool
odd : int -> bool
even : int -> bool
not : bool -> bool
--------------------------------------------------------
[ OK ]   recs3.hopix

INPUT:
rec f x : int := f (x + 0).

OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   recs4.hopix

INPUT:
rec f (x : int) : int := f x.

OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   recs5.hopix

INPUT:
rec f (g : int -> int) x : int := f g (g x).

OUTPUT: 
f : (int -> int) -> int -> int
EXPECTED: 
f : (int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  recs6.hopix

INPUT:
rec f (g : int -> int) := g 0
and g (x : char) := 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
EXPECTED: 
g : char -> int
f : (int -> int) -> int
--------------------------------------------------------
[ OK ]   recs7.hopix

INPUT:
rec f x : int := g x
and g x := h x
and h x := i x
and i x := f (x + 1).
OUTPUT: 
i : int -> int
h : int -> int
g : int -> int
f : int -> int
EXPECTED: 
i : int -> int
h : int -> int
g : int -> int
f : int -> int
--------------------------------------------------------
[ OK ]   recs.hopix

INPUT:
rec f x := g (x + 0)
and g x := 0.
OUTPUT: 
g : int -> int
f : int -> int
EXPECTED: 
g : int -> int
f : int -> int
--------------------------------------------------------
[ OK ]   stringvar2.hopix

INPUT:
val s := "Hello Hopix!".
val f x :=
  val id x := x;
  val z := id s;
  id x.
OUTPUT: 
f : string -> string
s : string
EXPECTED: 
f : string -> string
s : string
--------------------------------------------------------
[ OK ]   stringvar.hopix

INPUT:
val s := "Hello Hopix!".

OUTPUT: 
s : string
EXPECTED: 
s : string
--------------------------------------------------------
[ OK ]   tagged.hopix

INPUT:
type t := { A | B }.
val x := A.
val y := B.
OUTPUT: 
y : t
x : t
EXPECTED: 
y : t
x : t
--------------------------------------------------------
[ OK ]   varrecord.hopix

INPUT:
val x := 1.
type p := { x : char }.
val p := ({ x := 'a' })#x.
OUTPUT: 
p : char
x : int
EXPECTED: 
p : char
x : int
--------------------------------------------------------
[ OK ]   varvar2.hopix

INPUT:
val x := 1.
val y :=
  val x := 'a';
  x.
OUTPUT: 
y : char
x : int
EXPECTED: 
y : char
x : int
--------------------------------------------------------
[ KO ]   -->  varvar3.hopix

INPUT:
val x := 'a'.
val f x := x + 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
EXPECTED: 
f : int -> int
x : char
--------------------------------------------------------
[ OK ]   varvar.hopix

INPUT:
val x := 1.
val y := x.
OUTPUT: 
y : int
x : int
EXPECTED: 
y : int
x : int
--------------------------------------------------------
GOOD: 41 / 45
BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/good'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/good'
========================================================
In simpletypes/good
[ KO ]   -->  checkapply2.hopix

INPUT:
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> int).
val y := (f 0 1 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
y : int
f : int -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkapply3.hopix

INPUT:
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> int).
val h := (f 0 : int -> int).
val y := (h 1 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
y : int
h : int -> int
f : int -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkapply4.hopix

INPUT:
val apply :=
  (\((f : int -> int) : int -> int) =>
    (\(x : int) => (f x : int) : int -> int)
  : (int -> int) -> int -> int).
val x := (apply (\(x : int) => (x : int)) 0 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
x : int
apply : (int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkapply.hopix

INPUT:
val f := (\(x : int) => (`* 2 x : int) : int -> int).
val y := (f 0 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
y : int
f : int -> int
--------------------------------------------------------
[ OK ]   checkboolvar.hopix

INPUT:
val b := (true : bool).

OUTPUT: 
b : bool
EXPECTED: 
b : bool
--------------------------------------------------------
[ KO ]   -->  checkcase10.hopix

INPUT:
type r := { x : int }.
type a := { A : r }.
val get :=
  (\(a : a) =>
    ((a : a) ? { | A ({ x = 0 }) => 1 | A ({ x = (x : int) }) => x }
    : int)
  : a -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
get : a -> int
--------------------------------------------------------
[ KO ]   -->  checkcase2.hopix

INPUT:
type l := { N | C : int * l }.
rec
 len :=
  (\(x : l) =>
    ((x : l) ? { | N => 0 | C (_, (xs : l)) => `+ 1 (len xs) }
    : int)
  : l -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
len : l -> int
--------------------------------------------------------
[ KO ]   -->  checkcase3.hopix

INPUT:
val f :=
  (\(x : int) => ((x : int) ? { | ((y : int) : int) => y } : int)
  : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkcase4.hopix

INPUT:
val fint :=
  (\(x : int) => ((x : int) ? { | 42 => 0 | _ => 1 } : int)
  : int -> int).
val fbool :=
  (\(x : bool) =>
    ((x : bool) ? { | true => 0 | false => 1 } : int)
  : bool -> int).
val fchar :=
  (\(x : char) => ((x : char) ? { | 'a' => 0 | _ => 1 } : int)
  : char -> int).
val fstring :=
  (\(x : string) =>
    ((x : string) ? { | "Luke" => 0 | _ => 1 } : int)
  : string -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
fstring : string -> int
fchar : char -> int
fbool : bool -> int
fint : int -> int
--------------------------------------------------------
[ KO ]   -->  checkcase5.hopix

INPUT:
type p := { x : int ; y : int }.
val projx :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => z } : int)
  : p -> int).
val projy :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => u } : int)
  : p -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ KO ]   -->  checkcase6.hopix

INPUT:
type o := { None | Some : int }.
val complete :=
  (\(o : o) =>
    ((o : o) ? { | (Some (_) & (x : o)) => x | _ => Some (0) } : o)
  : o -> o).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
complete : o -> o
--------------------------------------------------------
[ KO ]   -->  checkcase7.hopix

INPUT:
type t := { A : int | B : int }.
val f :=
  (\(x : t) =>
    ((x : t) ? { | (A ((x : int)) | B ((x : int))) => x } : int)
  : t -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ KO ]   -->  checkcase8.hopix

INPUT:
type t := { L : int | B : t * t }.
val max :=
  (\(x : int) =>
    (\(y : int) => (if `> x y then x else x fi : int) : int -> int)
  : int -> int -> int).
rec
 depth :=
  (\(t : t) =>
    ((t : t) ?
    {
    | L ((x : int)) => 1
    | B ((a : t), (b : t)) => max (depth a) (depth b)
    }
    : int)
  : t -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation5")
EXPECTED: 
depth : t -> int
max : int -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkcase9.hopix

INPUT:
type t := { L : int | B : t * t }.
rec
 leaf :=
  (\(t : t) =>
    ((t : t) ?
    {
    |
      (L
      ((x
      :
      int))
      |
      B
      (L
      ((x
      :
      int)),
      _)
      |
      B
      (_,
      L
      ((x
      :
      int))))
      =>
      x
    | B ((a : t), (b : t)) => leaf a
    }
    : int)
  : t -> int).


OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
leaf : t -> int
--------------------------------------------------------
[ KO ]   -->  checkcase.hopix

INPUT:
type t := { A | B }.
val f :=
  (\(x : t) => ((x : t) ? { | A => 0 | B => 1 } : int) : t -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ OK ]   checkcharvar.hopix

INPUT:
val c := ('a' : char).

OUTPUT: 
c : char
EXPECTED: 
c : char
--------------------------------------------------------
[ KO ]   -->  checkfun2.hopix

INPUT:
val f :=
  (val y := (0 : int); \(x : int) => (`+ y x : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkfun3.hopix

INPUT:
val f :=
  (val y := (0 : int);
  \(x : int) => ((\(z : int) => (`+ y x : int)) y : int)
  : int -> int).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkfun4.hopix

INPUT:
val g :=
  (\(x : ((int -> int) -> int -> int) -> int -> int) =>
    (\(y : (int -> int) -> int -> int) =>
      (\((z : int -> int) : int -> int) =>
        ((x y ((y z (z 0) : int)) : int) : int)
      : (int -> int) -> int)
    : ((int -> int) -> int -> int) -> (int -> int) -> int)
  :
  (((int -> int) -> int -> int) -> int -> int)
  ->
  ((int -> int) -> int -> int) -> (int -> int) -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
g : (((int -> int) -> int -> int) -> int -> int)
->
((int -> int) -> int -> int) -> (int -> int) -> int
--------------------------------------------------------
[ KO ]   -->  checkfun5.hopix

INPUT:
rec
 omega :=
  (\(f : (int -> int) -> int -> int) =>
    (\((x : int) : int) => ((f (omega f) x : int) : int)
    : int -> int)
  : ((int -> int) -> int -> int) -> int -> int).
val fact :=
  (omega
  (\(fact : int -> int) =>
    (\(n : int) => (if `= n 0 then 1 else 1 fi : int) : int -> int))
  : int -> int).
val z := (fact 5 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
z : int
fact : int -> int
omega : ((int -> int) -> int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkfun.hopix

INPUT:
val f := (\(x : int) => (`+ x 1 : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkifthenelse.hopix

INPUT:
val f :=
  (\(x : bool) =>
    (\(y : bool) => (if x then 1 else 1 fi : int) : bool -> int)
  : bool -> bool -> int).
val x := (f true true : int).
val y := (f false false : int).
val z := (f false true : int).
val t := (f true false : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation5")
EXPECTED: 
t : int
z : int
y : int
x : int
f : bool -> bool -> int
--------------------------------------------------------
[ OK ]   checkintvar.hopix

INPUT:
val x := (1 : int).

OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ KO ]   -->  checkiszero.hopix

INPUT:
val iszero := (\(x : int) => (`= x 0 : bool) : int -> bool).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
iszero : int -> bool
--------------------------------------------------------
[ KO ]   -->  checklazy.hopix

INPUT:
type int_computation := { Todo : int -> int | Done : int }.
type lazy_int := { cell : int_computation }.
val lazy :=
  (\(e : int -> int) => ({ cell := Todo (e) } : lazy_int)
  : (int -> int) -> lazy_int).
val force :=
  (\({ cell = (x : int_computation) } & (l : lazy_int)) =>
    ((x : int_computation) ?
    {
    | Todo ((compute : int -> int)) =>
      val y := (compute 0 : int);
      val u := (l#cell <- Done (y) : unit); y
    | Done ((y : int)) => y
    }
    : int)
  : lazy_int -> int).
type ref_int := { content : int }.
val xr := ({ content := 0 } : ref_int).
val lz :=
  (lazy
  (\(x : int) => (val u := (xr#content <- 42 : unit); 1 : int))
  : lazy_int).
val y := (xr#content : int).
val z := (val u := (force lz : int); xr#content : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation6")
EXPECTED: 
z : int
y : int
lz : lazy_int
xr : ref_int
force : lazy_int -> int
lazy : (int -> int) -> lazy_int
--------------------------------------------------------
[ KO ]   -->  checklistmonad.hopix

INPUT:
type list := { Nil | Cons : int * list }.
rec
 append :=
  (\(l1 : list) =>
    (\(l2 : list) =>
      ((l1 : list) ?
      {
      | Nil => l2
      | Cons ((x : int), (xs : list)) => Cons (x, append xs l2)
      }
      : list)
    : list -> list)
  : list -> list -> list).
rec
 flatmap :=
  (\(f : int -> list) =>
    (\(l : list) =>
      ((l : list) ?
      {
      | Nil => Nil
      | Cons ((x : int), (xs : list)) => append (f x) (flatmap f xs)
      }
      : list)
    : list -> list)
  : (int -> list) -> list -> list).
val return :=
  (\(x : int) => (Cons (x, Nil) : list) : int -> list).
val bind :=
  (\(x : list) =>
    (\(f : int -> list) => (flatmap f x : list)
    : (int -> list) -> list)
  : list -> (int -> list) -> list).
val fail := (Nil : list).
val return_if :=
  (\(what : int) =>
    (\(condition : int -> bool) =>
      (if condition what then return what else return what fi : list)
    : (int -> bool) -> list)
  : int -> (int -> bool) -> list).
rec
 range :=
  (\(start : int) =>
    (\(stop : int) => (if `> start stop then Nil else Nil fi : list)
    : int -> list)
  : int -> int -> list).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
range : int -> int -> list
return_if : int -> (int -> bool) -> list
fail : list
bind : list -> (int -> list) -> list
return : int -> list
flatmap : (int -> list) -> list -> list
append : list -> list -> list
--------------------------------------------------------
[ KO ]   -->  checklocaldefine.hopix

INPUT:
val x := (val y := (42 : int); y : int).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
x : int
--------------------------------------------------------
[ KO ]   -->  checklocalrecs.hopix

INPUT:
val test :=
  (val not :=
      (\(b : bool) => (if b then false else false fi : bool)
      : bool -> bool);
  rec
     even :=
      (\(x : int) => (if `= x 0 then true else true fi : bool)
      : int -> bool)
    and
     odd := (\(x : int) => (not (even x) : bool) : int -> bool);
  val ahah := (even 42 : bool);
  val ohoh := (even 43 : bool); ahah || ohoh
  : bool).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
test : bool
--------------------------------------------------------
[ KO ]   -->  checkrecord2.hopix

INPUT:
type p := { x : int ; y : int }.
val projx := (\(p : p) => (p#x : int) : p -> int).
val projy := (\(p : p) => (p#y : int) : p -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation9")
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ KO ]   -->  checkrecord3.hopix

INPUT:
type p := { x : int ; y : int }.
val updatex :=
  (\(p : p) => (\(x : int) => (p#x <- x : unit) : int -> unit)
  : p -> int -> unit).
val updatey :=
  (\(p : p) => (\(y : int) => (p#y <- y : unit) : int -> unit)
  : p -> int -> unit).

OUTPUT: 
Fatal error: exception Failure("Bad annotation10")
EXPECTED: 
updatey : p -> int -> unit
updatex : p -> int -> unit
--------------------------------------------------------
[ KO ]   -->  checkrecord.hopix

INPUT:
type p := { x : int ; y : int }.
val make :=
  (\(x : int) =>
    (\(y : int) => ({ x := x; y := y } : p) : int -> p)
  : int -> int -> p).

OUTPUT: 
Fatal error: exception Failure("Error")
EXPECTED: 
make : int -> int -> p
--------------------------------------------------------
[ KO ]   -->  checkrecs2.hopix

INPUT:
val not :=
  (\(b : bool) => (if b then false else false fi : bool)
  : bool -> bool).
rec
 even :=
  (\(x : int) => (if `= x 0 then true else true fi : bool)
  : int -> bool)
and odd := (\(x : int) => (not (even x) : bool) : int -> bool).
val ahah := (even 42 : bool).
val ohoh := (even 43 : bool).

OUTPUT: 
Fatal error: exception Failure("Bad annotation5")
EXPECTED: 
ohoh : bool
ahah : bool
odd : int -> bool
even : int -> bool
not : bool -> bool
--------------------------------------------------------
[ KO ]   -->  checkrecs3.hopix

INPUT:
rec
 f := (\(x : int) => ((f (`+ x 0) : int) : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs4.hopix

INPUT:
rec
 f := (\((x : int) : int) => ((f x : int) : int) : int -> int).


OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs5.hopix

INPUT:
rec
 f :=
  (\((g : int -> int) : int -> int) =>
    (\(x : int) => ((f g (g x) : int) : int) : int -> int)
  : (int -> int) -> int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : (int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs6.hopix

INPUT:
rec
 f :=
  (\((g : int -> int) : int -> int) => (g 0 : int)
  : (int -> int) -> int)
and g := (\((x : char) : char) => (0 : int) : char -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
g : char -> int
f : (int -> int) -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs7.hopix

INPUT:
rec
 f := (\(x : int) => ((g x : int) : int) : int -> int)
and g := (\(x : int) => (h x : int) : int -> int)
and h := (\(x : int) => (i x : int) : int -> int)
and i := (\(x : int) => (f (`+ x 1) : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
i : int -> int
h : int -> int
g : int -> int
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs.hopix

INPUT:
rec
 f := (\(x : int) => (g (`+ x 0) : int) : int -> int)
and g := (\(x : int) => (0 : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
g : int -> int
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkstringvar2.hopix

INPUT:
val s := ("Hello Hopix!" : string).
val f :=
  (\(x : string) =>
    (val id := (\(x : string) => (x : string) : string -> string);
    val z := (id s : string); id x
    : string)
  : string -> string).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
f : string -> string
s : string
--------------------------------------------------------
[ OK ]   checkstringvar.hopix

INPUT:
val s := ("Hello Hopix!" : string).

OUTPUT: 
s : string
EXPECTED: 
s : string
--------------------------------------------------------
[ OK ]   checktagged.hopix

INPUT:
type t := { A | B }.
val x := (A : t).
val y := (B : t).

OUTPUT: 
y : t
x : t
EXPECTED: 
y : t
x : t
--------------------------------------------------------
[ KO ]   -->  checkvarrecord.hopix

INPUT:
val x := (1 : int).
type p := { x : char }.
val p := (({ x := 'a' })#x : char).

OUTPUT: 
Fatal error: exception Failure("Bad annotation9")
EXPECTED: 
p : char
x : int
--------------------------------------------------------
[ KO ]   -->  checkvarvar2.hopix

INPUT:
val x := (1 : int).
val y := (val x := ('a' : char); x : char).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
y : char
x : int
--------------------------------------------------------
[ KO ]   -->  checkvarvar3.hopix

INPUT:
val x := ('a' : char).
val f := (\(x : int) => (`+ x 0 : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
x : char
--------------------------------------------------------
[ OK ]   checkvarvar.hopix

INPUT:
val x := (1 : int).
val y := (x : int).

OUTPUT: 
y : int
x : int
EXPECTED: 
y : int
x : int
--------------------------------------------------------
[ OK ]   intvar.hopix

INPUT:
val x : int := 1.

OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
GOOD: 7 / 46
BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/good'
--------------------------------------------------------
Global results:
BAD:   92 / 92
GOOD:  48 / 91
--------------------------------------------------------
make[1]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests'=> J'ai trouvé une archive.
=> Je la décompresse.
flap-uzenat-elouraoui-15.3/
flap-uzenat-elouraoui-15.3/myocamlbuild_config.ml
flap-uzenat-elouraoui-15.3/Makefile.local
flap-uzenat-elouraoui-15.3/src/
flap-uzenat-elouraoui-15.3/src/retrolix/
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixLexer.mll
flap-uzenat-elouraoui-15.3/src/retrolix/graph.ml
flap-uzenat-elouraoui-15.3/src/retrolix/fopixToRetrolix.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/retrolix/graphColoring.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixParser.mly
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixInitialization.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixCompression.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixRegisterAllocation.ml
flap-uzenat-elouraoui-15.3/src/retrolix/graph.mli
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixAST.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/retrolix/retrolix.ml
flap-uzenat-elouraoui-15.3/src/fopix/
flap-uzenat-elouraoui-15.3/src/fopix/fopix.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/fopix/hobixToFopix.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixInitialization.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixAST.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixLexer.mll
flap-uzenat-elouraoui-15.3/src/fopix/fopixParser.mly
flap-uzenat-elouraoui-15.3/src/fopix/fopixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/fopix/fopixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/version.ml
flap-uzenat-elouraoui-15.3/src/common/
flap-uzenat-elouraoui-15.3/src/common/compilers.ml
flap-uzenat-elouraoui-15.3/src/common/languages.ml
flap-uzenat-elouraoui-15.3/src/options.ml
flap-uzenat-elouraoui-15.3/src/hopix/
flap-uzenat-elouraoui-15.3/src/hopix/memory.mli
flap-uzenat-elouraoui-15.3/src/hopix/hopixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/hopix/memory.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixLexer.mll
flap-uzenat-elouraoui-15.3/src/hopix/hopixAST.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixParser.mly
flap-uzenat-elouraoui-15.3/src/hopix/hopix.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixTypes.ml
flap-uzenat-elouraoui-15.3/src/hopix/hopixInitialization.ml
flap-uzenat-elouraoui-15.3/src/lib/
flap-uzenat-elouraoui-15.3/src/lib/pprint/
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintEngine.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/LICENSE
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintOCaml.mli
flap-uzenat-elouraoui-15.3/src/lib/pprint/CHANGES
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintRenderer.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintEngine.mli
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrint.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/AUTHORS
flap-uzenat-elouraoui-15.3/src/lib/pprint/README
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintCombinators.ml
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintCombinators.mli
flap-uzenat-elouraoui-15.3/src/lib/pprint/Makefile
flap-uzenat-elouraoui-15.3/src/lib/pprint/PPrintOCaml.ml
flap-uzenat-elouraoui-15.3/src/hobix/
flap-uzenat-elouraoui-15.3/src/hobix/bmemory.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobix.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixAST.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixInterpreter.ml
flap-uzenat-elouraoui-15.3/src/hobix/bmemory.mli
flap-uzenat-elouraoui-15.3/src/hobix/hobixTypechecker.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixLexer.mll
flap-uzenat-elouraoui-15.3/src/hobix/hobixInitialization.ml
flap-uzenat-elouraoui-15.3/src/hobix/hopixToHobix.ml
flap-uzenat-elouraoui-15.3/src/hobix/hobixParser.mly
flap-uzenat-elouraoui-15.3/src/hobix/hobixTypes.ml
flap-uzenat-elouraoui-15.3/src/flap.ml
flap-uzenat-elouraoui-15.3/src/mips/
flap-uzenat-elouraoui-15.3/src/mips/mipsArch.ml
flap-uzenat-elouraoui-15.3/src/mips/mips.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsInitialization.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsInterpreter.ml
flap-uzenat-elouraoui-15.3/src/mips/retrolixToMips.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsTypechecker.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsAST.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsPrettyPrinter.ml
flap-uzenat-elouraoui-15.3/src/mips/mipsLexer.mll
flap-uzenat-elouraoui-15.3/src/mips/mipsParser.mly
flap-uzenat-elouraoui-15.3/src/utilities/
flap-uzenat-elouraoui-15.3/src/utilities/userInput.ml
flap-uzenat-elouraoui-15.3/src/utilities/listMonad.ml
flap-uzenat-elouraoui-15.3/src/utilities/position.ml
flap-uzenat-elouraoui-15.3/src/utilities/dict.mli
flap-uzenat-elouraoui-15.3/src/utilities/error.ml
flap-uzenat-elouraoui-15.3/src/utilities/syntacticAnalysis.ml
flap-uzenat-elouraoui-15.3/src/utilities/position.mli
flap-uzenat-elouraoui-15.3/src/utilities/error.mli
flap-uzenat-elouraoui-15.3/src/utilities/listMonad.mli
flap-uzenat-elouraoui-15.3/src/utilities/extPPrint.ml
flap-uzenat-elouraoui-15.3/src/utilities/int16.ml
flap-uzenat-elouraoui-15.3/src/utilities/syntacticAnalysis.mli
flap-uzenat-elouraoui-15.3/src/utilities/stdUserInput.ml
flap-uzenat-elouraoui-15.3/src/utilities/option.ml
flap-uzenat-elouraoui-15.3/src/utilities/extStd.ml
flap-uzenat-elouraoui-15.3/src/utilities/dict.ml
flap-uzenat-elouraoui-15.3/src/utilities/int16.mli
flap-uzenat-elouraoui-15.3/src/commandLineOptions.ml
flap-uzenat-elouraoui-15.3/_tags
flap-uzenat-elouraoui-15.3/Makefile.generic
flap-uzenat-elouraoui-15.3/Makefile.config
flap-uzenat-elouraoui-15.3/Makefile
=> Je compile.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
ocamlfind ocamldep -package unix -package str -modules src/flap.ml > src/flap.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/commandLineOptions.ml > src/commandLineOptions.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/options.ml > src/options.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.mli > src/utilities/error.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.mli > src/utilities/position.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/position.cmi src/utilities/position.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/error.cmi src/utilities/error.mli
ocamlfind ocamldep -package unix -package str -modules src/version.ml > src/version.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/options.cmo src/options.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/version.cmo src/version.ml
ocamlfind ocamldep -package unix -package str -modules src/common/compilers.ml > src/common/compilers.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extStd.ml > src/utilities/extStd.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/common/languages.ml > src/common/languages.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extStd.cmo src/utilities/extStd.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/languages.cmo src/common/languages.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixInitialization.ml > src/fopix/fopixInitialization.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/compilers.cmo src/common/compilers.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopix.ml > src/fopix/fopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixAST.ml > src/fopix/fopixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixInterpreter.ml > src/fopix/fopixInterpreter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/bmemory.mli > src/hobix/bmemory.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixAST.cmo src/fopix/fopixAST.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/bmemory.cmi src/hobix/bmemory.mli
/usr/bin/ocamllex -q src/fopix/fopixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixLexer.ml > src/fopix/fopixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/fopix/fopixParser.mly > src/fopix/fopixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/fopix/fopixParser.mly
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixParser.mli > src/fopix/fopixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixParser.cmi src/fopix/fopixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixPrettyPrinter.ml > src/fopix/fopixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrint.ml > src/lib/pprint/PPrint.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.mli > src/lib/pprint/PPrintCombinators.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.mli > src/lib/pprint/PPrintEngine.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintRenderer.ml > src/lib/pprint/PPrintRenderer.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintRenderer.cmo src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintEngine.cmi src/lib/pprint/PPrintEngine.mli
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.mli > src/lib/pprint/PPrintOCaml.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintCombinators.cmi src/lib/pprint/PPrintCombinators.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintOCaml.cmi src/lib/pprint/PPrintOCaml.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrint.cmo src/lib/pprint/PPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixTypechecker.ml > src/fopix/fopixTypechecker.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.mli > src/utilities/syntacticAnalysis.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmo src/fopix/fopixInterpreter.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmo src/fopix/fopixInterpreter.ml
File "src/fopix/fopixInterpreter.ml", line 180, characters 25-1160:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
UnknownFunCall (_, _)
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixLexer.cmo src/fopix/fopixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixPrettyPrinter.cmo src/fopix/fopixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixTypechecker.cmo src/fopix/fopixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmi src/utilities/syntacticAnalysis.mli
ocamlfind ocamldep -package unix -package str -modules src/fopix/hobixToFopix.ml > src/fopix/hobixToFopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/dict.mli > src/utilities/dict.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopix.cmo src/fopix/fopix.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobix.ml > src/hobix/hobix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixAST.ml > src/hobix/hobixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixInterpreter.ml > src/hobix/hobixInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixAST.cmo src/hobix/hobixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixPrettyPrinter.ml > src/hobix/hobixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extPPrint.ml > src/utilities/extPPrint.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extPPrint.cmo src/utilities/extPPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixTypechecker.ml > src/hobix/hobixTypechecker.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixAST.ml > src/hopix/hopixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/listMonad.mli > src/utilities/listMonad.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/listMonad.cmi src/utilities/listMonad.mli
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixPrettyPrinter.ml > src/hopix/hopixPrettyPrinter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixAST.cmo src/hopix/hopixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypes.ml > src/hopix/hopixTypes.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/dict.cmi src/utilities/dict.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmo src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypes.cmo src/hopix/hopixTypes.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInterpreter.cmo src/hobix/hobixInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixPrettyPrinter.cmo src/hobix/hobixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixTypechecker.cmo src/hobix/hobixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobix.cmo src/hobix/hobix.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/hobixToFopix.cmo src/fopix/hobixToFopix.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/hobixInitialization.ml > src/hobix/hobixInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hobix/hopixToHobix.ml > src/hobix/hopixToHobix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopix.ml > src/hopix/hopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInterpreter.ml > src/hopix/hopixInterpreter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.mli > src/hopix/memory.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/memory.cmi src/hopix/memory.mli
/usr/bin/ocamllex -q src/hopix/hopixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixLexer.ml > src/hopix/hopixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/hopix/hopixParser.mly > src/hopix/hopixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/hopix/hopixParser.mly
+ menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/hopix/hopixParser.mly
File "src/hopix/hopixParser.mly", line 44, characters 0-5:
Warning: the precedence level assigned to SHARP is never useful.
Warning: one state has shift/reduce conflicts.
Warning: one shift/reduce conflict was arbitrarily resolved.
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.mli > src/hopix/hopixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixParser.cmi src/hopix/hopixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypechecker.ml > src/hopix/hopixTypechecker.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInterpreter.cmo src/hopix/hopixInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixLexer.cmo src/hopix/hopixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypechecker.cmo src/hopix/hopixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopix.cmo src/hopix/hopix.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hopixToHobix.cmo src/hobix/hopixToHobix.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInitialization.ml > src/hopix/hopixInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsInitialization.ml > src/mips/mipsInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mips.ml > src/mips/mips.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsAST.ml > src/mips/mipsAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/int16.mli > src/utilities/int16.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsArch.ml > src/mips/mipsArch.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/int16.cmi src/utilities/int16.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsArch.cmo src/mips/mipsArch.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsInterpreter.ml > src/mips/mipsInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsAST.cmo src/mips/mipsAST.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsPrettyPrinter.ml > src/mips/mipsPrettyPrinter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsPrettyPrinter.cmo src/mips/mipsPrettyPrinter.ml
/usr/bin/ocamllex -q src/mips/mipsLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsLexer.ml > src/mips/mipsLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/mips/mipsParser.mly > src/mips/mipsParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/mips/mipsParser.mly
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsParser.mli > src/mips/mipsParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsParser.cmi src/mips/mipsParser.mli
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsTypechecker.ml > src/mips/mipsTypechecker.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInterpreter.cmo src/mips/mipsInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsLexer.cmo src/mips/mipsLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsTypechecker.cmo src/mips/mipsTypechecker.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/retrolixToMips.ml > src/mips/retrolixToMips.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mips.cmo src/mips/mips.ml
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolix.ml > src/retrolix/retrolix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixAST.ml > src/retrolix/retrolixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixInterpreter.ml > src/retrolix/retrolixInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixAST.cmo src/retrolix/retrolixAST.ml
/usr/bin/ocamllex -q src/retrolix/retrolixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixLexer.ml > src/retrolix/retrolixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/retrolix/retrolixParser.mly > src/retrolix/retrolixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint' --explain --infer src/retrolix/retrolixParser.mly
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixParser.mli > src/retrolix/retrolixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixParser.cmi src/retrolix/retrolixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixPrettyPrinter.ml > src/retrolix/retrolixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixTypechecker.ml > src/retrolix/retrolixTypechecker.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInterpreter.cmo src/retrolix/retrolixInterpreter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixLexer.cmo src/retrolix/retrolixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmo src/retrolix/retrolixPrettyPrinter.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmo src/retrolix/retrolixPrettyPrinter.ml
File "src/retrolix/retrolixPrettyPrinter.ml", line 105, characters 14-113:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(LBool _|LChar _|LString _)
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixTypechecker.cmo src/retrolix/retrolixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolix.cmo src/retrolix/retrolix.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmo src/mips/retrolixToMips.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmo src/mips/retrolixToMips.ml
File "src/mips/retrolixToMips.ml", line 86, characters 4-536:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
`Immediate (LBool _|LChar _|LString _)
File "src/mips/retrolixToMips.ml", line 27, characters 10-15:
Warning 26: unused variable block.
File "src/mips/retrolixToMips.ml", line 39, characters 6-17:
Warning 26: unused variable instruction.
File "src/mips/retrolixToMips.ml", line 42, characters 6-10:
Warning 26: unused variable call.
File "src/mips/retrolixToMips.ml", line 45, characters 6-20:
Warning 26: unused variable load_immediate.
File "src/mips/retrolixToMips.ml", line 50, characters 6-10:
Warning 26: unused variable tmp1.
File "src/mips/retrolixToMips.ml", line 51, characters 6-10:
Warning 26: unused variable tmp2.
File "src/mips/retrolixToMips.ml", line 55, characters 6-14:
Warning 26: unused variable register.
File "src/mips/retrolixToMips.ml", line 69, characters 6-18:
Warning 26: unused variable mk_operation.
File "src/mips/retrolixToMips.ml", line 85, characters 6-17:
Warning 26: unused variable load_rvalue.
File "src/mips/retrolixToMips.ml", line 106, characters 6-22:
Warning 26: unused variable variable_address.
File "src/mips/retrolixToMips.ml", line 111, characters 6-19:
Warning 26: unused variable load_variable.
File "src/mips/retrolixToMips.ml", line 124, characters 6-20:
Warning 26: unused variable store_variable.
File "src/mips/retrolixToMips.ml", line 136, characters 6-25:
Warning 26: unused variable function_definition.
File "src/mips/retrolixToMips.ml", line 142, characters 6-26:
Warning 26: unused variable allocate_stack_frame.
File "src/mips/retrolixToMips.ml", line 147, characters 6-22:
Warning 26: unused variable free_stack_frame.
File "src/mips/retrolixToMips.ml", line 106, characters 37-52:
Warning 26: unused variable x.
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixInitialization.ml > src/retrolix/retrolixInitialization.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/fopixToRetrolix.ml > src/retrolix/fopixToRetrolix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixRegisterAllocation.ml > src/retrolix/retrolixRegisterAllocation.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/graphColoring.ml > src/retrolix/graphColoring.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/retrolix/graph.mli > src/retrolix/graph.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/option.ml > src/utilities/option.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graph.cmi src/retrolix/graph.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/option.cmo src/utilities/option.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmo src/retrolix/graphColoring.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmo src/retrolix/graphColoring.ml
File "src/retrolix/graphColoring.ml", line 194, characters 6-17:
Warning 21: this statement never returns (or has an unsound type.)
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixRegisterAllocation.cmo src/retrolix/retrolixRegisterAllocation.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/fopixToRetrolix.cmo src/retrolix/fopixToRetrolix.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/userInput.ml > src/utilities/userInput.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/stdUserInput.ml > src/utilities/stdUserInput.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/stdUserInput.cmo src/utilities/stdUserInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/commandLineOptions.cmo src/commandLineOptions.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInitialization.cmo src/fopix/fopixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInitialization.cmo src/hobix/hobixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInitialization.cmo src/hopix/hopixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInitialization.cmo src/mips/mipsInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInitialization.cmo src/retrolix/retrolixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/userInput.cmo src/utilities/userInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/flap.cmo src/flap.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.ml > src/utilities/error.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.ml > src/utilities/position.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/position.cmx src/utilities/position.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/error.cmx src/utilities/error.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/options.cmx src/options.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/version.cmx src/version.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extStd.cmx src/utilities/extStd.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/languages.cmx src/common/languages.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/common/compilers.cmx src/common/compilers.ml
ocamlfind ocamldep -package unix -package str -modules src/hobix/bmemory.ml > src/hobix/bmemory.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixAST.cmx src/fopix/fopixAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/bmemory.cmx src/hobix/bmemory.ml
ocamlfind ocamldep -package unix -package str -modules src/fopix/fopixParser.ml > src/fopix/fopixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixParser.cmx src/fopix/fopixParser.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.ml > src/lib/pprint/PPrintCombinators.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.ml > src/lib/pprint/PPrintEngine.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintEngine.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.ml > src/lib/pprint/PPrintOCaml.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintCombinators.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrintOCaml.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -o src/lib/pprint/PPrint.cmx src/lib/pprint/PPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.ml > src/utilities/syntacticAnalysis.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmx src/fopix/fopixInterpreter.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInterpreter.cmx src/fopix/fopixInterpreter.ml
File "src/fopix/fopixInterpreter.ml", line 180, characters 25-1160:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
UnknownFunCall (_, _)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixLexer.cmx src/fopix/fopixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixPrettyPrinter.cmx src/fopix/fopixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixTypechecker.cmx src/fopix/fopixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmx src/utilities/syntacticAnalysis.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/dict.ml > src/utilities/dict.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopix.cmx src/fopix/fopix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixAST.cmx src/hobix/hobixAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/extPPrint.cmx src/utilities/extPPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/listMonad.ml > src/utilities/listMonad.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/listMonad.cmx src/utilities/listMonad.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixAST.cmx src/hopix/hopixAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/dict.cmx src/utilities/dict.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmx src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypes.cmx src/hopix/hopixTypes.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInterpreter.cmx src/hobix/hobixInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixPrettyPrinter.cmx src/hobix/hobixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixTypechecker.cmx src/hobix/hobixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobix.cmx src/hobix/hobix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/hobixToFopix.cmx src/fopix/hobixToFopix.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.ml > src/hopix/memory.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/memory.cmx src/hopix/memory.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.ml > src/hopix/hopixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixParser.cmx src/hopix/hopixParser.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInterpreter.cmx src/hopix/hopixInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixLexer.cmx src/hopix/hopixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixTypechecker.cmx src/hopix/hopixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopix.cmx src/hopix/hopix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hopixToHobix.cmx src/hobix/hopixToHobix.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/int16.ml > src/utilities/int16.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/int16.cmx src/utilities/int16.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/int16.cmx src/utilities/int16.ml
File "src/utilities/int16.ml", line 20, characters 2-19:
Warning 21: this statement never returns (or has an unsound type.)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsArch.cmx src/mips/mipsArch.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsAST.cmx src/mips/mipsAST.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsPrettyPrinter.cmx src/mips/mipsPrettyPrinter.ml
ocamlfind ocamldep -package unix -package str -modules src/mips/mipsParser.ml > src/mips/mipsParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsParser.cmx src/mips/mipsParser.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInterpreter.cmx src/mips/mipsInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsLexer.cmx src/mips/mipsLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsTypechecker.cmx src/mips/mipsTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mips.cmx src/mips/mips.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixAST.cmx src/retrolix/retrolixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/retrolix/retrolixParser.ml > src/retrolix/retrolixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixParser.cmx src/retrolix/retrolixParser.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInterpreter.cmx src/retrolix/retrolixInterpreter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixLexer.cmx src/retrolix/retrolixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmx src/retrolix/retrolixPrettyPrinter.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixPrettyPrinter.cmx src/retrolix/retrolixPrettyPrinter.ml
File "src/retrolix/retrolixPrettyPrinter.ml", line 105, characters 14-113:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
(LBool _|LChar _|LString _)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixTypechecker.cmx src/retrolix/retrolixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolix.cmx src/retrolix/retrolix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmx src/mips/retrolixToMips.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/retrolixToMips.cmx src/mips/retrolixToMips.ml
File "src/mips/retrolixToMips.ml", line 86, characters 4-536:
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a value that is not matched:
`Immediate (LBool _|LChar _|LString _)
File "src/mips/retrolixToMips.ml", line 27, characters 10-15:
Warning 26: unused variable block.
File "src/mips/retrolixToMips.ml", line 39, characters 6-17:
Warning 26: unused variable instruction.
File "src/mips/retrolixToMips.ml", line 42, characters 6-10:
Warning 26: unused variable call.
File "src/mips/retrolixToMips.ml", line 45, characters 6-20:
Warning 26: unused variable load_immediate.
File "src/mips/retrolixToMips.ml", line 50, characters 6-10:
Warning 26: unused variable tmp1.
File "src/mips/retrolixToMips.ml", line 51, characters 6-10:
Warning 26: unused variable tmp2.
File "src/mips/retrolixToMips.ml", line 55, characters 6-14:
Warning 26: unused variable register.
File "src/mips/retrolixToMips.ml", line 69, characters 6-18:
Warning 26: unused variable mk_operation.
File "src/mips/retrolixToMips.ml", line 85, characters 6-17:
Warning 26: unused variable load_rvalue.
File "src/mips/retrolixToMips.ml", line 106, characters 6-22:
Warning 26: unused variable variable_address.
File "src/mips/retrolixToMips.ml", line 111, characters 6-19:
Warning 26: unused variable load_variable.
File "src/mips/retrolixToMips.ml", line 124, characters 6-20:
Warning 26: unused variable store_variable.
File "src/mips/retrolixToMips.ml", line 136, characters 6-25:
Warning 26: unused variable function_definition.
File "src/mips/retrolixToMips.ml", line 142, characters 6-26:
Warning 26: unused variable allocate_stack_frame.
File "src/mips/retrolixToMips.ml", line 147, characters 6-22:
Warning 26: unused variable free_stack_frame.
File "src/mips/retrolixToMips.ml", line 106, characters 37-52:
Warning 26: unused variable x.
ocamlfind ocamldep -package unix -package str -modules src/retrolix/graph.ml > src/retrolix/graph.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graph.cmx src/retrolix/graph.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/option.cmx src/utilities/option.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmx src/retrolix/graphColoring.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/graphColoring.cmx src/retrolix/graphColoring.ml
File "src/retrolix/graphColoring.ml", line 194, characters 6-17:
Warning 21: this statement never returns (or has an unsound type.)
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixRegisterAllocation.cmx src/retrolix/retrolixRegisterAllocation.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/fopixToRetrolix.cmx src/retrolix/fopixToRetrolix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/stdUserInput.cmx src/utilities/stdUserInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/commandLineOptions.cmx src/commandLineOptions.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/fopix -I src -I src/common -I src/retrolix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/fopix/fopixInitialization.cmx src/fopix/fopixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hobix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/lib/pprint -o src/hobix/hobixInitialization.cmx src/hobix/hobixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/utilities -I src/hobix -I src/lib/pprint -o src/hopix/hopixInitialization.cmx src/hopix/hopixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/mips -I src -I src/common -I src/retrolix -I src/fopix -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/mips/mipsInitialization.cmx src/mips/mipsInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/retrolix -I src -I src/common -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/retrolix/retrolixInitialization.cmx src/retrolix/retrolixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/hobix -I src/lib/pprint -o src/utilities/userInput.cmx src/utilities/userInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/retrolix -I src/fopix -I src/mips -I src/hopix -I src/utilities -I src/hobix -I src/lib/pprint -o src/flap.cmx src/flap.ml
ocamlfind ocamlopt -linkpkg -package unix -package str src/utilities/position.cmx src/utilities/error.cmx src/options.cmx src/version.cmx src/commandLineOptions.cmx src/common/languages.cmx src/utilities/extStd.cmx src/common/compilers.cmx src/fopix/fopixAST.cmx src/hobix/bmemory.cmx src/fopix/fopixInterpreter.cmx src/fopix/fopixParser.cmx src/fopix/fopixLexer.cmx src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrint.cmx src/fopix/fopixPrettyPrinter.cmx src/fopix/fopixTypechecker.cmx src/utilities/syntacticAnalysis.cmx src/fopix/fopix.cmx src/hobix/hobixAST.cmx src/hobix/hobixInterpreter.cmx src/utilities/extPPrint.cmx src/hobix/hobixPrettyPrinter.cmx src/utilities/listMonad.cmx src/hopix/hopixAST.cmx src/hopix/hopixPrettyPrinter.cmx src/utilities/dict.cmx src/hopix/hopixTypes.cmx src/hobix/hobixTypechecker.cmx src/hobix/hobix.cmx src/fopix/hobixToFopix.cmx src/fopix/fopixInitialization.cmx src/hopix/memory.c
ln -s flap.native flap
=> Je lance les tests.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make -C tests check
make[1]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests'
make -C ..
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3'
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/bad'
========================================================
In infersimpletypes/bad
GOOD: 0 / 0
[XFAIL]  apply2.hopix

INPUT: 
val f x y := 2 * x + y.
val y := f 0 true.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  apply3.hopix

INPUT: 
val f x y := 2 * x + y.
val h := f 0.
val y := h 1 2.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  apply4.hopix

INPUT: 
val apply (f : int -> int) x := f x 0.
val x := apply (\x => x) 0.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  apply.hopix

INPUT: 
val f x := 2 * x + 1.
val y := f 'a'.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  boolvar.hopix

INPUT: 
val b : string := true.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case10.hopix

INPUT: 
type r := { x : int }.
type a := { A : r }.

val get a := a ? { A ({ x = 0 }) => 1 | A ({ x = z }) => x }.
OUTPUT: 
Line 4, characters 57-58: Error (typechecking)
  Unbound identifier `x'.
--------------------------------------------------------
[XFAIL]  case2.hopix

INPUT: 
type l := { N | C : int * l }.
rec len x := x ? {
    | N => 0
    | C xs => 1 + len xs
}.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  case3.hopix

INPUT: 
val f (x : char) := x ? { (y : int) => y }.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case4.hopix

INPUT: 
val fint x := x ? { 42 => 0 | _ => 1 }.
val fbool x := x ? { true => 0 | 0 => 1 }.
val fchar x := x ? { 'a' => 0 | _ => 1 }.
val fstring x := x ? { "Luke" => 0 | _ => 1 }.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case5.hopix

INPUT: 
type p := { x : int; y : int }.

val projx p := p ? { { x = z; y = u } => z }.
val projy p := p ? { { x = z; u = y } => u }.
OUTPUT: 
Fatal error: exception Not_found
--------------------------------------------------------
[XFAIL]  case6.hopix

INPUT: 
type o := { None | Some : int }.

val complete o := o ? { Some & x => x | _ => Some (0) }.
OUTPUT: 
Fatal error: exception Invalid_argument("List.fold_left2")
--------------------------------------------------------
[XFAIL]  case7.hopix

INPUT: 
type t := { A : int | B : int }.

val f x := x ? { A (x) | B (x) => z }.
OUTPUT: 
Fatal error: exception Failure("not ground ")
--------------------------------------------------------
[XFAIL]  case8.hopix

INPUT: 
type t := { L : int | B : t * t }.

val max x y :=
 if x > y then x else y fi.

rec depth t := t ? {
  | L (x) => 1
  | B (a, b) => max a b
}.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  case9.hopix

INPUT: 
type t := { L : int | B : t * t }.

rec leaf t :=
    t ? {
    | L (x) | B (L (x), _) | B (_) => x
    }.

OUTPUT: 
Fatal error: exception Invalid_argument("List.fold_left2")
--------------------------------------------------------
[XFAIL]  case.hopix

INPUT: 
type t := { A | B }.
val f x := x ? { A => 0 | B => "Larzac" }.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  charvar.hopix

INPUT: 
val c : bool := 'a'.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  fun2.hopix

INPUT: 
val f :=
  val y := 0;
  \(x : char) => y + x.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  fun3.hopix

INPUT: 
val f :=
  val y := 0;
  \x => (\z => u + x) y.
OUTPUT: 
Line 3, characters 15-16: Error (typechecking)
  Unbound identifier `u'.
--------------------------------------------------------
[XFAIL]  fun4.hopix

INPUT: 
val g := \x (y : int -> int) (z : int -> int) =>
    ((x y (y z (z 0) : int -> int)) : int -> int -> int).

OUTPUT: 
Global Error (during parsing)
  Syntax error.
--------------------------------------------------------
[XFAIL]  fun5.hopix

INPUT: 
rec omega f (x : int) : int := f (omega f) x.
val fact := omega (\fact n => if n = 0 then 1 else n * fact (n - 1) fi).
val z := fact 5 32.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  fun.hopix

INPUT: 
val f : int := \x => x + 1.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  ifthenelse.hopix

INPUT: 
val f x y :=
    if x then 1 else if y then 2 else "Larzac" fi fi.

val x := f true true.
val y := f false false.
val z := f false true.
val t := f true false.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  intvar.hopix

INPUT: 
val x : char := 1.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  iszero.hopix

INPUT: 
val iszero := \(x : int) => (x = "zero?").

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  lazy.hopix

INPUT: 
type int_computation := {
  | Todo : int -> int
  | Done : int
}.

type lazy_int := { cell : int_computation }.

val lazy e := { cell := Todo (e) }.

val force ({ cell = x } & l) := x ? {
    | Todo (compute) =>
      val y := compute 0;
      val u := l#cell <- Done (y);
      y
    | Done (y) =>
      y
}.

type ref_int := { content : int }.

val xr := { content := 0 }.
val lz := lazy (\x => val u := xr#content <- "Larzac"; 1).
val y := xr#content.
val z :=
  val u := force lz;
  xr#content.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  listmonad.hopix

INPUT: 
type list := { Nil | Cons : int * list }.

rec append l1 l2 :=
  l1 ? { Nil => l2 | Cons (x, xs) => Cons (x, append xs l2) }.

rec flatmap f l :=
   l ? {
   | Nil => Nil
   | Cons (x, xs) => append (f x) (flatmap f xs)
   }.

val return x := Cons (x, Nil).
val bind x f := flatmap f x.
val fail := Nil.
val return_if what condition :=
  if condition (what) then return what else fail fi.

rec range start stop :=
  if start > stop then Nil else Cons (start, range (start + 1) stop) fi.

val all_sum start stop :=
  bind (range start stop) (\x =>
  bind (range start stop) (\y =>
    return_if (x + y) (\z => z = 10 && x > y)
  )).

rec len l :=
  l ? { Nil => 0 | Cons (_, xs) => 1 + len xs }.

val tens := len (all_sum 0).
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  localdefine2.hopix

INPUT: 
val x :=
    val y : string := 42;
    y.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  localdefine.hopix

INPUT: 
val x : string :=
    val y := 42;
    y.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  localrecs.hopix

INPUT: 
val test :=
  val not b := if b then false else true fi;
  rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
  and odd x := not (even (x));
  val ahah := even 42;
  val ohoh := 1 + even 43;
  ahah || ohoh.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  record2.hopix

INPUT: 
type p := { x : int; y : int }.

val projx p := p#x.

val projy p := p#z.
OUTPUT: 
Fatal error: exception Assert_failure("src/hopix/hopixTypechecker.ml", 1046, 16)
--------------------------------------------------------
[XFAIL]  record3.hopix

INPUT: 
type p := { x : int; y : int }.

val updatex p x := p#x <- x.
val updatey (p : int) y := p#y <- y.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  record.hopix

INPUT: 
type p := { x : int; y : int }.

val make x y := { x := x; z := y }.
OUTPUT: 
Fatal error: exception Assert_failure("src/hopix/hopixTypechecker.ml", 1041, 16)
--------------------------------------------------------
[XFAIL]  recs2.hopix

INPUT: 
val not b := if b then false else true fi.
rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
and odd x := 0 - even (x).
val ahah := even 42.
val ohoh := even 43.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs3.hopix

INPUT: 
rec f (x : string) : int := f (x + 0).

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs4.hopix

INPUT: 
rec f (x : int) : int := f true.

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs5.hopix

INPUT: 
rec f (g : int -> int) x : int := f g (g x 0).

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs6.hopix

INPUT: 
rec f (x : int)  := g 0
and g (x : char) := 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs7.hopix

INPUT: 
rec f x : int := g x
and g x := h x
and h x := i x
and i x := f (x + 1) 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  recs.hopix

INPUT: 
rec f x := g (x + 0)
and g (x : bool) := 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  stringvar2.hopix

INPUT: 
val s := "Hello Hopix!".
val f x : int :=
  val id x := x;
  val z := id s;
  id x.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  stringvar.hopix

INPUT: 
val s : int := "Hello Hopix!".

OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  tagged.hopix

INPUT: 
type t := { A }.
val x := A.
val y := B.
OUTPUT: 
Fatal error: exception Failure("impossible")
--------------------------------------------------------
[XFAIL]  varrecord.hopix

INPUT: 
val x := 1.
type p := { x : char }.
val p := ({ x := 'a' })#y.
OUTPUT: 
Fatal error: exception Assert_failure("src/hopix/hopixTypechecker.ml", 1046, 16)
--------------------------------------------------------
[XFAIL]  varvar2.hopix

INPUT: 
val x := 1.
val y :=
  val x := 'a';
  z.
OUTPUT: 
Fatal error: exception Failure("not ground ")
--------------------------------------------------------
[XFAIL]  varvar3.hopix

INPUT: 
val x := 'a'.
val f y := x + 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
--------------------------------------------------------
[XFAIL]  varvar.hopix

INPUT: 
val y := x.
OUTPUT: 
Fatal error: exception Failure("not ground ")
--------------------------------------------------------
./apply2.hopix ./apply3.hopix ./apply4.hopix ./apply.hopix ./boolvar.hopix ./case10.hopix ./case2.hopix ./case3.hopix ./case4.hopix ./case5.hopix ./case6.hopix ./case7.hopix ./case8.hopix ./case9.hopix ./case.hopix ./charvar.hopix ./fun2.hopix ./fun3.hopix ./fun4.hopix ./fun5.hopix ./fun.hopix ./ifthenelse.hopix ./intvar.hopix ./iszero.hopix ./lazy.hopix ./listmonad.hopix ./localdefine2.hopix ./localdefine.hopix ./localrecs.hopix ./record2.hopix ./record3.hopix ./record.hopix ./recs2.hopix ./recs3.hopix ./recs4.hopix ./recs5.hopix ./recs6.hopix ./recs7.hopix ./recs.hopix ./stringvar2.hopix ./stringvar.hopix ./tagged.hopix ./varrecord.hopix ./varvar2.hopix ./varvar3.hopix ./varvar.hopix
BAD:  46 / 46
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/bad'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/bad'
========================================================
In simpletypes/bad
GOOD: 0 / 0
[XFAIL]  checkapply2.hopix

INPUT: 
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> int).
val y := (f 0 1 : char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkapply3.hopix

INPUT: 
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> string).
val h := (f 0 : int -> int).
val y := (h 1 : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkapply4.hopix

INPUT: 
val apply :=
  (\((f : int -> int) : int -> int) =>
    (\(x : int) => (f x : int) : int -> int)
  : (int -> int) -> int -> int).
val x := (apply (\(x : int) => (x : bool)) 0 : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkapply.hopix

INPUT: 
val f := (\(x : int) => (`* 2 x : int) : int -> int).
val y := (f 0 : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkboolvar.hopix

INPUT: 
val b := (0 : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase10.hopix

INPUT: 
type r := { x : int }.
type a := { A : t }.
val get :=
  (\(a : a) =>
    ((a : a) ? { | A ({ x = 0 }) => 1 | A ({ x = (x : int) }) => x }
    : int)
  : a -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase2.hopix

INPUT: 
type l := { N | C : l * int }.
rec
 len :=
  (\(x : l) =>
    ((x : l) ? { | N => 0 | C (_, (xs : l)) => `+ 1 (len xs) }
    : int)
  : l -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase3.hopix

INPUT: 
val f :=
  (\(x : char) => ((x : int) ? { | ((y : int) : int) => y } : int)
  : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase4.hopix

INPUT: 
val fint :=
  (\(x : int) => ((x : int) ? { | 42 => 0 | _ => 1 } : int)
  : int -> int).
val fbool :=
  (\(x : bool) =>
    ((x : bool) ? { | true => 0 | false => 1 } : int)
  : bool -> int).
val fchar :=
  (\(x : bool) => ((x : char) ? { | 'a' => 0 | _ => 1 } : int)
  : char -> int).
val fstring :=
  (\(x : string) =>
    ((x : string) ? { | "Luke" => 0 | _ => 1 } : int)
  : string -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase5.hopix

INPUT: 
type p := { x : int ; y : bool }.
val projx :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => z } : int)
  : p -> int).
val projy :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => u } : int)
  : p -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase6.hopix

INPUT: 
type o := { None | Some : char }.
val complete :=
  (\(o : o) =>
    ((o : o) ? { | (Some (_) & (x : o)) => x | _ => Some (0) } : o)
  : o -> o).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase7.hopix

INPUT: 
type t := { A : int | B : char }.
val f :=
  (\(x : t) =>
    ((x : t) ? { | (A ((x : int)) | B ((x : int))) => x } : int)
  : t -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase8.hopix

INPUT: 
type t := { L : int | B : t * t }.
val max :=
  (\(x : int) =>
    (\(y : int) => (if `> x y then x else x fi : int) : int -> int)
  : int -> int -> int).
rec
 depth :=
  (\(t : t) =>
    ((t : t) ?
    {
    | L ((x : char)) => 1
    | B ((a : t), (b : t)) => max (depth a) (depth b)
    }
    : int)
  : t -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase9.hopix

INPUT: 
type t := { L : int | B : t }.
rec
 leaf :=
  (\(t : t) =>
    ((t : t) ?
    {
    |
      (L
      ((x
      :
      int))
      |
      B
      (L
      ((x
      :
      int)),
      _)
      |
      B
      (_,
      L
      ((x
      :
      int))))
      =>
      x
    | B ((a : t), (b : t)) => leaf a
    }
    : int)
  : t -> int).


OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcase.hopix

INPUT: 
type t := { A | B }.
val f :=
  (\(x : t) => ((x : t) ? { | A => 0 | B => 1 } : bool) : t -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkcharvar.hopix

INPUT: 
val c := ('a' : string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun2.hopix

INPUT: 
val f :=
  (val y := (0 : int); \(x : int) => (`+ y x : bool) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun3.hopix

INPUT: 
val f :=
  (val y := (0 : int);
  \(x : int) => ((\(z : int) => (`+ y x : int)) y : int)
  : int -> int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun4.hopix

INPUT: 
val g :=
  (\(x : ((int -> int) -> int -> int) -> int -> int) =>
    (\(y : (int -> int) -> int -> int) =>
      (\((z : int -> int) : int -> int) =>
        ((x y ((y z (z 0) : int)) : bool) : int)
      : (int -> int) -> int)
    : ((int -> int) -> int -> int) -> (int -> int) -> int)
  :
  (((int -> int) -> int -> int) -> int -> int)
  ->
  ((int -> int) -> int -> int) -> (int -> int) -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun5.hopix

INPUT: 
rec
 omega :=
  (\(f : (int -> int) -> int -> int) =>
    (\((x : int) : int) => ((f (omega f) x : int) : int)
    : int -> int)
  : ((int -> int) -> int -> int) -> int -> int).
val fact :=
  (omega
  (\(fact : int -> int) =>
    (\(n : int) => (if `= n 0 then 1 else 1 fi : int) : int -> char))
  : int -> int).
val z := (fact 5 : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkfun.hopix

INPUT: 
val f := (\(x : int) => (`+ x 1 : int) : int -> char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkifthenelse.hopix

INPUT: 
val f :=
  (\(x : bool) =>
    (\(y : bool) => (if x then 1 else 1 fi : int) : bool -> int)
  : bool -> bool -> bool).
val x := (f true true : int).
val y := (f false false : int).
val z := (f false true : int).
val t := (f true false : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkintvar.hopix

INPUT: 
val x := (1 : char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkiszero.hopix

INPUT: 
val iszero := (\(x : int) => (`= x 0 : bool) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklazy.hopix

INPUT: 
type int_computation := { Todo : int -> int | Done : int }.
type lazy_int := { cell : int_computation }.
val lazy :=
  (\(e : int -> int) => ({ cell := Todo (e) } : lazy_int)
  : (int -> int) -> lazy_int).
val force :=
  (\({ cell = (x : int_computation) } & (l : lazy_int)) =>
    ((x : int_computation) ?
    {
    | Todo ((compute : int -> int)) =>
      val y := (compute 0 : int);
      val u := (l#cell <- Done (y) : unit); y
    | Done ((y : int)) => y
    }
    : int)
  : lazy_int -> int).
type ref_int := { content : int }.
val xr := ({ content := 0 } : ref_int).
val lz :=
  (lazy
  (\(x : int) => (val u := (xr#content <- 42 : unit); 1 : int))
  : lazy_int).
val y := (xr#content : int).
val z := (val u := (force lz : int); xr : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklistmonad.hopix

INPUT: 
type list := { Nil | Cons : int * list }.
rec
 append :=
  (\(l1 : list) =>
    (\(l2 : list) =>
      ((l1 : list) ?
      {
      | Nil => l2
      | Cons ((x : int), (xs : list)) => Cons (x, append xs l2)
      }
      : list)
    : list -> list)
  : list -> list -> list).
rec
 flatmap :=
  (\(f : int -> list) =>
    (\(l : list) =>
      ((l : list) ?
      {
      | Nil => Nil
      | Cons ((x : int), (xs : list)) => append (f x) (flatmap f xs)
      }
      : list)
    : list -> list)
  : (int -> list) -> list -> list).
val return :=
  (\(x : int) => (Cons (x, Cons) : list) : int -> list).
val bind :=
  (\(x : list) =>
    (\(f : int -> list) => (flatmap f x : list)
    : (int -> list) -> list)
  : list -> (int -> list) -> list).
val fail := (Nil : list).
val return_if :=
  (\(what : int) =>
    (\(condition : int -> bool) =>
      (if condition what then return what else return what fi : list)
    : (int -> bool) -> list)
  : int -> (int -> bool) -> list).
rec
 range :=
  (\(start : int) =>
    (\(stop : int) => (if `> start stop then Nil else Nil fi : list)
    : int -> list)
  : int -> int -> list).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklocaldefine.hopix

INPUT: 
val x := (val y := ('a' : int); y : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checklocalrecs.hopix

INPUT: 
val test :=
  (val not :=
      (\(b : bool) => (if b then false else false fi : bool)
      : bool -> bool);
  rec
     even :=
      (\(x : int) => (if `= x 'a' then true else true fi : bool)
      : int -> bool)
    and
     odd := (\(x : int) => (not (even x) : bool) : int -> bool);
  val ahah := (even 42 : bool);
  val ohoh := (even 43 : bool); ahah || ohoh
  : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecord2.hopix

INPUT: 
type p := { x : int ; y : int }.
val projx := (\(p : p) => (p#x : int) : p -> int).
val projy := (\(p : p) => (p#z : int) : p -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecord3.hopix

INPUT: 
type p := { x : int ; y : char }.
val updatex :=
  (\(p : p) => (\(x : int) => (p#x <- x : unit) : int -> unit)
  : p -> int -> unit).
val updatey :=
  (\(p : p) => (\(y : int) => (p#y <- y : unit) : int -> unit)
  : p -> int -> unit).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecord.hopix

INPUT: 
type p := { x : int ; z : int }.
val make :=
  (\(x : int) =>
    (\(y : int) => ({ x := x; y := y } : p) : int -> p)
  : int -> int -> p).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs2.hopix

INPUT: 
val not :=
  (\(b : bool) => (if b then false else false fi : bool)
  : bool -> int).
rec
 even :=
  (\(x : int) => (if `= x 0 then true else true fi : bool)
  : int -> bool)
and odd := (\(x : int) => (not (even x) : bool) : int -> bool).
val ahah := (even 42 : bool).
val ohoh := (even 43 : bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs3.hopix

INPUT: 
rec
 f := (\(x : int) => ((f (`+ x 0) : int) : int) : int -> int -> char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs4.hopix

INPUT: 
rec
 f := (\((x : int) : bool) => ((f x : int) : int) : int -> int).


OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs5.hopix

INPUT: 
rec
 f :=
  (\((g : int -> int) : int -> int) =>
    (\(x : int) => ((f g (g x) : int) : int) : char -> int)
  : (int -> int) -> int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs6.hopix

INPUT: 
rec
 f :=
  (\((g : int -> int -> int) : int -> int) => (g 0 : int)
  : (int -> int -> int) -> int)
and g := (\((x : char) : char) => (0 : int) : char -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs7.hopix

INPUT: 
rec
 f := (\(x : int) => ((g x : int) : int) : int -> int)
and g := (\(x : int) => (h x : int) : int -> int)
and h := (\(x : int) => (i x : int) : int -> int)
and i := (\(x : int) => (f (`+ x 1) : int) : int -> bool).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkrecs.hopix

INPUT: 
rec
 f := (\(x : int) => (g (`+ x 'a') : int) : int -> int)
and g := (\(x : int) => (0 : int) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkstringvar2.hopix

INPUT: 
val s := ("Hello Hopix!" : string).
val f :=
  (\(x : string) =>
    (val id := (\(x : string) => (x : string) : string -> string);
    val z := (id s : char); id x
    : string)
  : string -> string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkstringvar.hopix

INPUT: 
val s := ("Hello Hopix!" : int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checktagged.hopix

INPUT: 
type t := { A | C }.
val x := (A : t).
val y := (B : t).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarrecord.hopix

INPUT: 
val x := (1 : int).
type p := { x : int }.
val p := (({ x := 'a' })#x : char).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarvar2.hopix

INPUT: 
val x := (1 : int).
val y := (val x := ('a' : char); x : string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarvar3.hopix

INPUT: 
val x := ('a' : char).
val f := (\(x : unit) => (`+ x 0 : int) : int -> int).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  checkvarvar.hopix

INPUT: 
val x := (1 : int).
val y := (x : string).

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
[XFAIL]  intvar.hopix

INPUT: 
val x : int := 'a'.

OUTPUT: 
Global Error (during analysis of options)
  You should specify the source language using '--source'.
--------------------------------------------------------
./checkapply2.hopix ./checkapply3.hopix ./checkapply4.hopix ./checkapply.hopix ./checkboolvar.hopix ./checkcase10.hopix ./checkcase2.hopix ./checkcase3.hopix ./checkcase4.hopix ./checkcase5.hopix ./checkcase6.hopix ./checkcase7.hopix ./checkcase8.hopix ./checkcase9.hopix ./checkcase.hopix ./checkcharvar.hopix ./checkfun2.hopix ./checkfun3.hopix ./checkfun4.hopix ./checkfun5.hopix ./checkfun.hopix ./checkifthenelse.hopix ./checkintvar.hopix ./checkiszero.hopix ./checklazy.hopix ./checklistmonad.hopix ./checklocaldefine.hopix ./checklocalrecs.hopix ./checkrecord2.hopix ./checkrecord3.hopix ./checkrecord.hopix ./checkrecs2.hopix ./checkrecs3.hopix ./checkrecs4.hopix ./checkrecs5.hopix ./checkrecs6.hopix ./checkrecs7.hopix ./checkrecs.hopix ./checkstringvar2.hopix ./checkstringvar.hopix ./checktagged.hopix ./checkvarrecord.hopix ./checkvarvar2.hopix ./checkvarvar3.hopix ./checkvarvar.hopix ./intvar.hopix
BAD:  46 / 46
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/bad'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/good'
========================================================
In infersimpletypes/good
[ OK ]   apply2.hopix

INPUT:
val f x y := 2 * x + y.
val y := f 0 1.
OUTPUT: 
y : int
f : int -> int -> int
EXPECTED: 
y : int
f : int -> int -> int
--------------------------------------------------------
[ OK ]   apply3.hopix

INPUT:
val f x y := 2 * x + y.
val h := f 0.
val y := h 1.
OUTPUT: 
y : int
h : int -> int
f : int -> int -> int
EXPECTED: 
y : int
h : int -> int
f : int -> int -> int
--------------------------------------------------------
[ OK ]   apply4.hopix

INPUT:
val apply (f : int -> int) x := f x.
val x := apply (\x => x) 0.

OUTPUT: 
x : int
apply : (int -> int) -> int -> int
EXPECTED: 
x : int
apply : (int -> int) -> int -> int
--------------------------------------------------------
[ OK ]   apply.hopix

INPUT:
val f x := 2 * x.
val y := f 0.
OUTPUT: 
y : int
f : int -> int
EXPECTED: 
y : int
f : int -> int
--------------------------------------------------------
[ OK ]   boolvar.hopix

INPUT:
val b := true.

OUTPUT: 
b : bool
EXPECTED: 
b : bool
--------------------------------------------------------
[ OK ]   case10.hopix

INPUT:
type r := { x : int }.
type a := { A : r }.

val get a := a ? { A ({ x = 0 }) => 1 | A ({ x = x }) => x }.
OUTPUT: 
get : a -> int
EXPECTED: 
get : a -> int
--------------------------------------------------------
[ OK ]   case2.hopix

INPUT:
type l := { N | C : int * l }.
rec len x := x ? {
    | N => 0
    | C (_, xs) => 1 + len xs
}.
OUTPUT: 
len : l -> int
EXPECTED: 
len : l -> int
--------------------------------------------------------
[ OK ]   case3.hopix

INPUT:
val f x := x ? { (y : int) => y }.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   case4.hopix

INPUT:
val fint x := x ? { 42 => 0 | _ => 1 }.
val fbool x := x ? { true => 0 | false => 1 }.
val fchar x := x ? { 'a' => 0 | _ => 1 }.
val fstring x := x ? { "Luke" => 0 | _ => 1 }.
OUTPUT: 
fstring : string -> int
fchar : char -> int
fbool : bool -> int
fint : int -> int
EXPECTED: 
fstring : string -> int
fchar : char -> int
fbool : bool -> int
fint : int -> int
--------------------------------------------------------
[ OK ]   case5.hopix

INPUT:
type p := { x : int; y : int }.

val projx p := p ? { { x = z; y = u } => z }.
val projy p := p ? { { x = z; y = u } => u }.
OUTPUT: 
projy : p -> int
projx : p -> int
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ OK ]   case6.hopix

INPUT:
type o := { None | Some : int }.

val complete o := o ? { Some (_) & x => x | _ => Some (0) }.
OUTPUT: 
complete : o -> o
EXPECTED: 
complete : o -> o
--------------------------------------------------------
[ OK ]   case7.hopix

INPUT:
type t := { A : int | B : int }.

val f x := x ? { A (x) | B (x) => x }.
OUTPUT: 
f : t -> int
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ OK ]   case8.hopix

INPUT:
type t := { L : int | B : t * t }.

val max x y :=
 if x > y then x else y fi.

rec depth t := t ? {
  | L (x) => 1
  | B (a, b) => max (depth a) (depth b)
}.
OUTPUT: 
depth : t -> int
max : int -> int -> int
EXPECTED: 
depth : t -> int
max : int -> int -> int
--------------------------------------------------------
[ OK ]   case9.hopix

INPUT:
type t := { L : int | B : t * t }.

rec leaf t :=
    t ? {
    | L (x) | B (L (x), _) | B (_, L(x)) => x
    | B (a, b) => leaf a
    }.
OUTPUT: 
leaf : t -> int
EXPECTED: 
leaf : t -> int
--------------------------------------------------------
[ OK ]   case.hopix

INPUT:
type t := { A | B }.
val f x := x ? { A => 0 | B => 1 }.
OUTPUT: 
f : t -> int
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ OK ]   charvar.hopix

INPUT:
val c := 'a'.

OUTPUT: 
c : char
EXPECTED: 
c : char
--------------------------------------------------------
[ OK ]   fun2.hopix

INPUT:
val f :=
  val y := 0;
  \x => y + x.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   fun3.hopix

INPUT:
val f :=
  val y := 0;
  \x => (\z => y + x) y.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  fun4.hopix

INPUT:
val g := \x y (z : int -> int) =>
    ((x y (y z (z 0) : int)) : int).
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
g : (((int -> int) -> int -> int) -> int -> int)
->
((int -> int) -> int -> int) -> (int -> int) -> int
--------------------------------------------------------
[ OK ]   fun5.hopix

INPUT:
rec omega f (x : int) : int := f (omega f) x.
val fact := omega (\fact n => if n = 0 then 1 else n * fact (n - 1) fi).
val z := fact 5.
OUTPUT: 
z : int
fact : int -> int
omega : ((int -> int) -> int -> int) -> int -> int
EXPECTED: 
z : int
fact : int -> int
omega : ((int -> int) -> int -> int) -> int -> int
--------------------------------------------------------
[ OK ]   fun.hopix

INPUT:
val f := \x => x + 1.
OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   ifthenelse.hopix

INPUT:
val f x y :=
    if x then 1 else if y then 2 else 3 fi fi.

val x := f true true.
val y := f false false.
val z := f false true.
val t := f true false.
OUTPUT: 
t : int
z : int
y : int
x : int
f : bool -> bool -> int
EXPECTED: 
t : int
z : int
y : int
x : int
f : bool -> bool -> int
--------------------------------------------------------
[ OK ]   intvar.hopix

INPUT:
val x := 1.

OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ OK ]   iszero.hopix

INPUT:
val iszero := \x => (x = 0).

OUTPUT: 
iszero : int -> bool
EXPECTED: 
iszero : int -> bool
--------------------------------------------------------
[ OK ]   lazy.hopix

INPUT:
type int_computation := {
  | Todo : int -> int
  | Done : int
}.

type lazy_int := { cell : int_computation }.

val lazy e := { cell := Todo (e) }.

val force ({ cell = x } & l) := x ? {
    | Todo (compute) =>
      val y := compute 0;
      val u := l#cell <- Done (y);
      y
    | Done (y) =>
      y
}.

type ref_int := { content : int }.

val xr := { content := 0 }.
val lz := lazy (\x => val u := xr#content <- 42; 1).
val y := xr#content.
val z :=
  val u := force lz;
  xr#content.

OUTPUT: 
z : int
y : int
lz : lazy_int
xr : ref_int
force : lazy_int -> int
lazy : (int -> int) -> lazy_int
EXPECTED: 
z : int
y : int
lz : lazy_int
xr : ref_int
force : lazy_int -> int
lazy : (int -> int) -> lazy_int
--------------------------------------------------------
[ OK ]   listmonad.hopix

INPUT:
type list := { Nil | Cons : int * list }.

rec append l1 l2 :=
  l1 ? { Nil => l2 | Cons (x, xs) => Cons (x, append xs l2) }.

rec flatmap f l :=
   l ? {
   | Nil => Nil
   | Cons (x, xs) => append (f x) (flatmap f xs)
   }.

val return x := Cons (x, Nil).
val bind x f := flatmap f x.
val fail := Nil.
val return_if what condition :=
  if condition (what) then return what else fail fi.

rec range start stop :=
  if start > stop then Nil else Cons (start, range (start + 1) stop) fi.

val all_sum start stop :=
  bind (range start stop) (\x =>
  bind (range start stop) (\y =>
    return_if (x + y) (\z => z = 10 && x > y)
  )).

rec len l :=
  l ? { Nil => 0 | Cons (_, xs) => 1 + len xs }.

val tens := len (all_sum 0 9).
OUTPUT: 
tens : int
len : list -> int
all_sum : int -> int -> list
range : int -> int -> list
return_if : int -> (int -> bool) -> list
fail : list
bind : list -> (int -> list) -> list
return : int -> list
flatmap : (int -> list) -> list -> list
append : list -> list -> list
EXPECTED: 
tens : int
len : list -> int
all_sum : int -> int -> list
range : int -> int -> list
return_if : int -> (int -> bool) -> list
fail : list
bind : list -> (int -> list) -> list
return : int -> list
flatmap : (int -> list) -> list -> list
append : list -> list -> list
--------------------------------------------------------
[ OK ]   localdefine.hopix

INPUT:
val x :=
    val y := 42;
    y.
OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ KO ]   -->  localrecs.hopix

INPUT:
val test :=
  val not b := if b then false else true fi;
  rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
  and odd x := not (even (x));
  val ahah := even 42;
  val ohoh := even 43;
  ahah || ohoh.
OUTPUT: 
Fatal error: exception Failure("not ground ")
EXPECTED: 
test : bool
--------------------------------------------------------
[ OK ]   record2.hopix

INPUT:
type p := { x : int; y : int }.

val projx p := p#x.

val projy p := p#y.
OUTPUT: 
projy : p -> int
projx : p -> int
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ OK ]   record3.hopix

INPUT:
type p := { x : int; y : int }.

val updatex p x := p#x <- x.
val updatey p y := p#y <- y.
OUTPUT: 
updatey : p -> int -> unit
updatex : p -> int -> unit
EXPECTED: 
updatey : p -> int -> unit
updatex : p -> int -> unit
--------------------------------------------------------
[ OK ]   record.hopix

INPUT:
type p := { x : int; y : int }.

val make x y := { x := x; y := y }.
OUTPUT: 
make : int -> int -> p
EXPECTED: 
make : int -> int -> p
--------------------------------------------------------
[ OK ]   recs2.hopix

INPUT:
val not b := if b then false else true fi.
rec even x := if (x = 0) then true else if (x = 1) then false else odd (x - 1) fi fi
and odd x := not (even (x)).
val ahah := even 42.
val ohoh := even 43.
OUTPUT: 
ohoh : bool
ahah : bool
odd : int -> bool
even : int -> bool
not : bool -> bool
EXPECTED: 
ohoh : bool
ahah : bool
odd : int -> bool
even : int -> bool
not : bool -> bool
--------------------------------------------------------
[ OK ]   recs3.hopix

INPUT:
rec f x : int := f (x + 0).

OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   recs4.hopix

INPUT:
rec f (x : int) : int := f x.

OUTPUT: 
f : int -> int
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ OK ]   recs5.hopix

INPUT:
rec f (g : int -> int) x : int := f g (g x).

OUTPUT: 
f : (int -> int) -> int -> int
EXPECTED: 
f : (int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  recs6.hopix

INPUT:
rec f (g : int -> int) := g 0
and g (x : char) := 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
EXPECTED: 
g : char -> int
f : (int -> int) -> int
--------------------------------------------------------
[ OK ]   recs7.hopix

INPUT:
rec f x : int := g x
and g x := h x
and h x := i x
and i x := f (x + 1).
OUTPUT: 
i : int -> int
h : int -> int
g : int -> int
f : int -> int
EXPECTED: 
i : int -> int
h : int -> int
g : int -> int
f : int -> int
--------------------------------------------------------
[ OK ]   recs.hopix

INPUT:
rec f x := g (x + 0)
and g x := 0.
OUTPUT: 
g : int -> int
f : int -> int
EXPECTED: 
g : int -> int
f : int -> int
--------------------------------------------------------
[ OK ]   stringvar2.hopix

INPUT:
val s := "Hello Hopix!".
val f x :=
  val id x := x;
  val z := id s;
  id x.
OUTPUT: 
f : string -> string
s : string
EXPECTED: 
f : string -> string
s : string
--------------------------------------------------------
[ OK ]   stringvar.hopix

INPUT:
val s := "Hello Hopix!".

OUTPUT: 
s : string
EXPECTED: 
s : string
--------------------------------------------------------
[ OK ]   tagged.hopix

INPUT:
type t := { A | B }.
val x := A.
val y := B.
OUTPUT: 
y : t
x : t
EXPECTED: 
y : t
x : t
--------------------------------------------------------
[ OK ]   varrecord.hopix

INPUT:
val x := 1.
type p := { x : char }.
val p := ({ x := 'a' })#x.
OUTPUT: 
p : char
x : int
EXPECTED: 
p : char
x : int
--------------------------------------------------------
[ OK ]   varvar2.hopix

INPUT:
val x := 1.
val y :=
  val x := 'a';
  x.
OUTPUT: 
y : char
x : int
EXPECTED: 
y : char
x : int
--------------------------------------------------------
[ KO ]   -->  varvar3.hopix

INPUT:
val x := 'a'.
val f x := x + 0.
OUTPUT: 
Fatal error: exception Failure("symbol clash !")
EXPECTED: 
f : int -> int
x : char
--------------------------------------------------------
[ OK ]   varvar.hopix

INPUT:
val x := 1.
val y := x.
OUTPUT: 
y : int
x : int
EXPECTED: 
y : int
x : int
--------------------------------------------------------
GOOD: 41 / 45
BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/infersimpletypes/good'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/good'
========================================================
In simpletypes/good
[ KO ]   -->  checkapply2.hopix

INPUT:
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> int).
val y := (f 0 1 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
y : int
f : int -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkapply3.hopix

INPUT:
val f :=
  (\(x : int) =>
    (\(y : int) => (`+ (`* 2 x) y : int) : int -> int)
  : int -> int -> int).
val h := (f 0 : int -> int).
val y := (h 1 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
y : int
h : int -> int
f : int -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkapply4.hopix

INPUT:
val apply :=
  (\((f : int -> int) : int -> int) =>
    (\(x : int) => (f x : int) : int -> int)
  : (int -> int) -> int -> int).
val x := (apply (\(x : int) => (x : int)) 0 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
x : int
apply : (int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkapply.hopix

INPUT:
val f := (\(x : int) => (`* 2 x : int) : int -> int).
val y := (f 0 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
y : int
f : int -> int
--------------------------------------------------------
[ OK ]   checkboolvar.hopix

INPUT:
val b := (true : bool).

OUTPUT: 
b : bool
EXPECTED: 
b : bool
--------------------------------------------------------
[ KO ]   -->  checkcase10.hopix

INPUT:
type r := { x : int }.
type a := { A : r }.
val get :=
  (\(a : a) =>
    ((a : a) ? { | A ({ x = 0 }) => 1 | A ({ x = (x : int) }) => x }
    : int)
  : a -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
get : a -> int
--------------------------------------------------------
[ KO ]   -->  checkcase2.hopix

INPUT:
type l := { N | C : int * l }.
rec
 len :=
  (\(x : l) =>
    ((x : l) ? { | N => 0 | C (_, (xs : l)) => `+ 1 (len xs) }
    : int)
  : l -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
len : l -> int
--------------------------------------------------------
[ KO ]   -->  checkcase3.hopix

INPUT:
val f :=
  (\(x : int) => ((x : int) ? { | ((y : int) : int) => y } : int)
  : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkcase4.hopix

INPUT:
val fint :=
  (\(x : int) => ((x : int) ? { | 42 => 0 | _ => 1 } : int)
  : int -> int).
val fbool :=
  (\(x : bool) =>
    ((x : bool) ? { | true => 0 | false => 1 } : int)
  : bool -> int).
val fchar :=
  (\(x : char) => ((x : char) ? { | 'a' => 0 | _ => 1 } : int)
  : char -> int).
val fstring :=
  (\(x : string) =>
    ((x : string) ? { | "Luke" => 0 | _ => 1 } : int)
  : string -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
fstring : string -> int
fchar : char -> int
fbool : bool -> int
fint : int -> int
--------------------------------------------------------
[ KO ]   -->  checkcase5.hopix

INPUT:
type p := { x : int ; y : int }.
val projx :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => z } : int)
  : p -> int).
val projy :=
  (\(p : p) =>
    ((p : p) ? { | { x = (z : int); y = (u : int) } => u } : int)
  : p -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ KO ]   -->  checkcase6.hopix

INPUT:
type o := { None | Some : int }.
val complete :=
  (\(o : o) =>
    ((o : o) ? { | (Some (_) & (x : o)) => x | _ => Some (0) } : o)
  : o -> o).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
complete : o -> o
--------------------------------------------------------
[ KO ]   -->  checkcase7.hopix

INPUT:
type t := { A : int | B : int }.
val f :=
  (\(x : t) =>
    ((x : t) ? { | (A ((x : int)) | B ((x : int))) => x } : int)
  : t -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ KO ]   -->  checkcase8.hopix

INPUT:
type t := { L : int | B : t * t }.
val max :=
  (\(x : int) =>
    (\(y : int) => (if `> x y then x else x fi : int) : int -> int)
  : int -> int -> int).
rec
 depth :=
  (\(t : t) =>
    ((t : t) ?
    {
    | L ((x : int)) => 1
    | B ((a : t), (b : t)) => max (depth a) (depth b)
    }
    : int)
  : t -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation5")
EXPECTED: 
depth : t -> int
max : int -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkcase9.hopix

INPUT:
type t := { L : int | B : t * t }.
rec
 leaf :=
  (\(t : t) =>
    ((t : t) ?
    {
    |
      (L
      ((x
      :
      int))
      |
      B
      (L
      ((x
      :
      int)),
      _)
      |
      B
      (_,
      L
      ((x
      :
      int))))
      =>
      x
    | B ((a : t), (b : t)) => leaf a
    }
    : int)
  : t -> int).


OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
leaf : t -> int
--------------------------------------------------------
[ KO ]   -->  checkcase.hopix

INPUT:
type t := { A | B }.
val f :=
  (\(x : t) => ((x : t) ? { | A => 0 | B => 1 } : int) : t -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
f : t -> int
--------------------------------------------------------
[ OK ]   checkcharvar.hopix

INPUT:
val c := ('a' : char).

OUTPUT: 
c : char
EXPECTED: 
c : char
--------------------------------------------------------
[ KO ]   -->  checkfun2.hopix

INPUT:
val f :=
  (val y := (0 : int); \(x : int) => (`+ y x : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkfun3.hopix

INPUT:
val f :=
  (val y := (0 : int);
  \(x : int) => ((\(z : int) => (`+ y x : int)) y : int)
  : int -> int).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkfun4.hopix

INPUT:
val g :=
  (\(x : ((int -> int) -> int -> int) -> int -> int) =>
    (\(y : (int -> int) -> int -> int) =>
      (\((z : int -> int) : int -> int) =>
        ((x y ((y z (z 0) : int)) : int) : int)
      : (int -> int) -> int)
    : ((int -> int) -> int -> int) -> (int -> int) -> int)
  :
  (((int -> int) -> int -> int) -> int -> int)
  ->
  ((int -> int) -> int -> int) -> (int -> int) -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
g : (((int -> int) -> int -> int) -> int -> int)
->
((int -> int) -> int -> int) -> (int -> int) -> int
--------------------------------------------------------
[ KO ]   -->  checkfun5.hopix

INPUT:
rec
 omega :=
  (\(f : (int -> int) -> int -> int) =>
    (\((x : int) : int) => ((f (omega f) x : int) : int)
    : int -> int)
  : ((int -> int) -> int -> int) -> int -> int).
val fact :=
  (omega
  (\(fact : int -> int) =>
    (\(n : int) => (if `= n 0 then 1 else 1 fi : int) : int -> int))
  : int -> int).
val z := (fact 5 : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
z : int
fact : int -> int
omega : ((int -> int) -> int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkfun.hopix

INPUT:
val f := (\(x : int) => (`+ x 1 : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkifthenelse.hopix

INPUT:
val f :=
  (\(x : bool) =>
    (\(y : bool) => (if x then 1 else 1 fi : int) : bool -> int)
  : bool -> bool -> int).
val x := (f true true : int).
val y := (f false false : int).
val z := (f false true : int).
val t := (f true false : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation5")
EXPECTED: 
t : int
z : int
y : int
x : int
f : bool -> bool -> int
--------------------------------------------------------
[ OK ]   checkintvar.hopix

INPUT:
val x := (1 : int).

OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
[ KO ]   -->  checkiszero.hopix

INPUT:
val iszero := (\(x : int) => (`= x 0 : bool) : int -> bool).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
iszero : int -> bool
--------------------------------------------------------
[ KO ]   -->  checklazy.hopix

INPUT:
type int_computation := { Todo : int -> int | Done : int }.
type lazy_int := { cell : int_computation }.
val lazy :=
  (\(e : int -> int) => ({ cell := Todo (e) } : lazy_int)
  : (int -> int) -> lazy_int).
val force :=
  (\({ cell = (x : int_computation) } & (l : lazy_int)) =>
    ((x : int_computation) ?
    {
    | Todo ((compute : int -> int)) =>
      val y := (compute 0 : int);
      val u := (l#cell <- Done (y) : unit); y
    | Done ((y : int)) => y
    }
    : int)
  : lazy_int -> int).
type ref_int := { content : int }.
val xr := ({ content := 0 } : ref_int).
val lz :=
  (lazy
  (\(x : int) => (val u := (xr#content <- 42 : unit); 1 : int))
  : lazy_int).
val y := (xr#content : int).
val z := (val u := (force lz : int); xr#content : int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation6")
EXPECTED: 
z : int
y : int
lz : lazy_int
xr : ref_int
force : lazy_int -> int
lazy : (int -> int) -> lazy_int
--------------------------------------------------------
[ KO ]   -->  checklistmonad.hopix

INPUT:
type list := { Nil | Cons : int * list }.
rec
 append :=
  (\(l1 : list) =>
    (\(l2 : list) =>
      ((l1 : list) ?
      {
      | Nil => l2
      | Cons ((x : int), (xs : list)) => Cons (x, append xs l2)
      }
      : list)
    : list -> list)
  : list -> list -> list).
rec
 flatmap :=
  (\(f : int -> list) =>
    (\(l : list) =>
      ((l : list) ?
      {
      | Nil => Nil
      | Cons ((x : int), (xs : list)) => append (f x) (flatmap f xs)
      }
      : list)
    : list -> list)
  : (int -> list) -> list -> list).
val return :=
  (\(x : int) => (Cons (x, Nil) : list) : int -> list).
val bind :=
  (\(x : list) =>
    (\(f : int -> list) => (flatmap f x : list)
    : (int -> list) -> list)
  : list -> (int -> list) -> list).
val fail := (Nil : list).
val return_if :=
  (\(what : int) =>
    (\(condition : int -> bool) =>
      (if condition what then return what else return what fi : list)
    : (int -> bool) -> list)
  : int -> (int -> bool) -> list).
rec
 range :=
  (\(start : int) =>
    (\(stop : int) => (if `> start stop then Nil else Nil fi : list)
    : int -> list)
  : int -> int -> list).

OUTPUT: 
Fatal error: exception Failure("Bad annotation")
EXPECTED: 
range : int -> int -> list
return_if : int -> (int -> bool) -> list
fail : list
bind : list -> (int -> list) -> list
return : int -> list
flatmap : (int -> list) -> list -> list
append : list -> list -> list
--------------------------------------------------------
[ KO ]   -->  checklocaldefine.hopix

INPUT:
val x := (val y := (42 : int); y : int).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
x : int
--------------------------------------------------------
[ KO ]   -->  checklocalrecs.hopix

INPUT:
val test :=
  (val not :=
      (\(b : bool) => (if b then false else false fi : bool)
      : bool -> bool);
  rec
     even :=
      (\(x : int) => (if `= x 0 then true else true fi : bool)
      : int -> bool)
    and
     odd := (\(x : int) => (not (even x) : bool) : int -> bool);
  val ahah := (even 42 : bool);
  val ohoh := (even 43 : bool); ahah || ohoh
  : bool).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
test : bool
--------------------------------------------------------
[ KO ]   -->  checkrecord2.hopix

INPUT:
type p := { x : int ; y : int }.
val projx := (\(p : p) => (p#x : int) : p -> int).
val projy := (\(p : p) => (p#y : int) : p -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation9")
EXPECTED: 
projy : p -> int
projx : p -> int
--------------------------------------------------------
[ KO ]   -->  checkrecord3.hopix

INPUT:
type p := { x : int ; y : int }.
val updatex :=
  (\(p : p) => (\(x : int) => (p#x <- x : unit) : int -> unit)
  : p -> int -> unit).
val updatey :=
  (\(p : p) => (\(y : int) => (p#y <- y : unit) : int -> unit)
  : p -> int -> unit).

OUTPUT: 
Fatal error: exception Failure("Bad annotation10")
EXPECTED: 
updatey : p -> int -> unit
updatex : p -> int -> unit
--------------------------------------------------------
[ KO ]   -->  checkrecord.hopix

INPUT:
type p := { x : int ; y : int }.
val make :=
  (\(x : int) =>
    (\(y : int) => ({ x := x; y := y } : p) : int -> p)
  : int -> int -> p).

OUTPUT: 
Fatal error: exception Failure("Error")
EXPECTED: 
make : int -> int -> p
--------------------------------------------------------
[ KO ]   -->  checkrecs2.hopix

INPUT:
val not :=
  (\(b : bool) => (if b then false else false fi : bool)
  : bool -> bool).
rec
 even :=
  (\(x : int) => (if `= x 0 then true else true fi : bool)
  : int -> bool)
and odd := (\(x : int) => (not (even x) : bool) : int -> bool).
val ahah := (even 42 : bool).
val ohoh := (even 43 : bool).

OUTPUT: 
Fatal error: exception Failure("Bad annotation5")
EXPECTED: 
ohoh : bool
ahah : bool
odd : int -> bool
even : int -> bool
not : bool -> bool
--------------------------------------------------------
[ KO ]   -->  checkrecs3.hopix

INPUT:
rec
 f := (\(x : int) => ((f (`+ x 0) : int) : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs4.hopix

INPUT:
rec
 f := (\((x : int) : int) => ((f x : int) : int) : int -> int).


OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs5.hopix

INPUT:
rec
 f :=
  (\((g : int -> int) : int -> int) =>
    (\(x : int) => ((f g (g x) : int) : int) : int -> int)
  : (int -> int) -> int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : (int -> int) -> int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs6.hopix

INPUT:
rec
 f :=
  (\((g : int -> int) : int -> int) => (g 0 : int)
  : (int -> int) -> int)
and g := (\((x : char) : char) => (0 : int) : char -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
g : char -> int
f : (int -> int) -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs7.hopix

INPUT:
rec
 f := (\(x : int) => ((g x : int) : int) : int -> int)
and g := (\(x : int) => (h x : int) : int -> int)
and h := (\(x : int) => (i x : int) : int -> int)
and i := (\(x : int) => (f (`+ x 1) : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
i : int -> int
h : int -> int
g : int -> int
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkrecs.hopix

INPUT:
rec
 f := (\(x : int) => (g (`+ x 0) : int) : int -> int)
and g := (\(x : int) => (0 : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
g : int -> int
f : int -> int
--------------------------------------------------------
[ KO ]   -->  checkstringvar2.hopix

INPUT:
val s := ("Hello Hopix!" : string).
val f :=
  (\(x : string) =>
    (val id := (\(x : string) => (x : string) : string -> string);
    val z := (id s : string); id x
    : string)
  : string -> string).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
f : string -> string
s : string
--------------------------------------------------------
[ OK ]   checkstringvar.hopix

INPUT:
val s := ("Hello Hopix!" : string).

OUTPUT: 
s : string
EXPECTED: 
s : string
--------------------------------------------------------
[ OK ]   checktagged.hopix

INPUT:
type t := { A | B }.
val x := (A : t).
val y := (B : t).

OUTPUT: 
y : t
x : t
EXPECTED: 
y : t
x : t
--------------------------------------------------------
[ KO ]   -->  checkvarrecord.hopix

INPUT:
val x := (1 : int).
type p := { x : char }.
val p := (({ x := 'a' })#x : char).

OUTPUT: 
Fatal error: exception Failure("Bad annotation9")
EXPECTED: 
p : char
x : int
--------------------------------------------------------
[ KO ]   -->  checkvarvar2.hopix

INPUT:
val x := (1 : int).
val y := (val x := ('a' : char); x : char).

OUTPUT: 
Fatal error: exception Failure("u Bad annotation2")
EXPECTED: 
y : char
x : int
--------------------------------------------------------
[ KO ]   -->  checkvarvar3.hopix

INPUT:
val x := ('a' : char).
val f := (\(x : int) => (`+ x 0 : int) : int -> int).

OUTPUT: 
Fatal error: exception Failure("Bad annotation4")
EXPECTED: 
f : int -> int
x : char
--------------------------------------------------------
[ OK ]   checkvarvar.hopix

INPUT:
val x := (1 : int).
val y := (x : int).

OUTPUT: 
y : int
x : int
EXPECTED: 
y : int
x : int
--------------------------------------------------------
[ OK ]   intvar.hopix

INPUT:
val x : int := 1.

OUTPUT: 
x : int
EXPECTED: 
x : int
--------------------------------------------------------
GOOD: 7 / 46
BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests/hopix/simpletypes/good'
--------------------------------------------------------
Global results:
BAD:   92 / 92
GOOD:  48 / 91
--------------------------------------------------------
make[1]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.3/tests'
