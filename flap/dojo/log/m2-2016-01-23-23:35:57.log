waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
waiting...
automatic:68/134
Trace:
=> J'ai trouvé une archive.
=> Je la décompresse.
flap-uzenat-elouraoui-15.2/
flap-uzenat-elouraoui-15.2/myocamlbuild_config.ml
flap-uzenat-elouraoui-15.2/Makefile.local
flap-uzenat-elouraoui-15.2/src/
flap-uzenat-elouraoui-15.2/src/version.ml
flap-uzenat-elouraoui-15.2/src/common/
flap-uzenat-elouraoui-15.2/src/common/compilers.ml
flap-uzenat-elouraoui-15.2/src/common/languages.ml
flap-uzenat-elouraoui-15.2/src/options.ml
flap-uzenat-elouraoui-15.2/src/hopix/
flap-uzenat-elouraoui-15.2/src/hopix/memory.mli
flap-uzenat-elouraoui-15.2/src/hopix/hopixTypechecker.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixInterpreter.ml
flap-uzenat-elouraoui-15.2/src/hopix/memory.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixLexer.mll
flap-uzenat-elouraoui-15.2/src/hopix/hopixTypeInferenceEngine.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixAST.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixPrettyPrinter.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixParser.mly
flap-uzenat-elouraoui-15.2/src/hopix/hopix.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixTypes.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixInitialization.ml
flap-uzenat-elouraoui-15.2/src/lib/
flap-uzenat-elouraoui-15.2/src/lib/pprint/
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintEngine.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/LICENSE
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintOCaml.mli
flap-uzenat-elouraoui-15.2/src/lib/pprint/CHANGES
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintRenderer.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintEngine.mli
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrint.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/AUTHORS
flap-uzenat-elouraoui-15.2/src/lib/pprint/README
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintCombinators.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintCombinators.mli
flap-uzenat-elouraoui-15.2/src/lib/pprint/Makefile
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintOCaml.ml
flap-uzenat-elouraoui-15.2/src/flap.ml
flap-uzenat-elouraoui-15.2/src/utilities/
flap-uzenat-elouraoui-15.2/src/utilities/userInput.ml
flap-uzenat-elouraoui-15.2/src/utilities/position.ml
flap-uzenat-elouraoui-15.2/src/utilities/error.ml
flap-uzenat-elouraoui-15.2/src/utilities/syntacticAnalysis.ml
flap-uzenat-elouraoui-15.2/src/utilities/position.mli
flap-uzenat-elouraoui-15.2/src/utilities/error.mli
flap-uzenat-elouraoui-15.2/src/utilities/extPPrint.ml
flap-uzenat-elouraoui-15.2/src/utilities/syntacticAnalysis.mli
flap-uzenat-elouraoui-15.2/src/utilities/stdUserInput.ml
flap-uzenat-elouraoui-15.2/src/utilities/option.ml
flap-uzenat-elouraoui-15.2/src/utilities/extStd.ml
flap-uzenat-elouraoui-15.2/src/commandLineOptions.ml
flap-uzenat-elouraoui-15.2/_tags
flap-uzenat-elouraoui-15.2/Makefile.generic
flap-uzenat-elouraoui-15.2/Makefile.config
flap-uzenat-elouraoui-15.2/Makefile
=> Je compile.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
ocamlfind ocamldep -package unix -package str -modules src/flap.ml > src/flap.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/commandLineOptions.ml > src/commandLineOptions.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/options.ml > src/options.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.mli > src/utilities/error.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.mli > src/utilities/position.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/position.cmi src/utilities/position.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/error.cmi src/utilities/error.mli
ocamlfind ocamldep -package unix -package str -modules src/version.ml > src/version.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/options.cmo src/options.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/version.cmo src/version.ml
ocamlfind ocamldep -package unix -package str -modules src/common/compilers.ml > src/common/compilers.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extStd.ml > src/utilities/extStd.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/common/languages.ml > src/common/languages.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extStd.cmo src/utilities/extStd.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/languages.cmo src/common/languages.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInitialization.ml > src/hopix/hopixInitialization.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/compilers.cmo src/common/compilers.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopix.ml > src/hopix/hopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixAST.ml > src/hopix/hopixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInterpreter.ml > src/hopix/hopixInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixAST.cmo src/hopix/hopixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.mli > src/hopix/memory.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/memory.cmi src/hopix/memory.mli
/usr/bin/ocamllex -q src/hopix/hopixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixLexer.ml > src/hopix/hopixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/hopix/hopixParser.mly > src/hopix/hopixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint' --explain --infer src/hopix/hopixParser.mly
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.mli > src/hopix/hopixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixParser.cmi src/hopix/hopixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixPrettyPrinter.ml > src/hopix/hopixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extPPrint.ml > src/utilities/extPPrint.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrint.ml > src/lib/pprint/PPrint.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.mli > src/lib/pprint/PPrintCombinators.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.mli > src/lib/pprint/PPrintEngine.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintRenderer.ml > src/lib/pprint/PPrintRenderer.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintRenderer.cmo src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintEngine.cmi src/lib/pprint/PPrintEngine.mli
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.mli > src/lib/pprint/PPrintOCaml.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintCombinators.cmi src/lib/pprint/PPrintCombinators.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintOCaml.cmi src/lib/pprint/PPrintOCaml.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrint.cmo src/lib/pprint/PPrint.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extPPrint.cmo src/utilities/extPPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypechecker.ml > src/hopix/hopixTypechecker.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypes.ml > src/hopix/hopixTypes.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypes.cmo src/hopix/hopixTypes.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.mli > src/utilities/syntacticAnalysis.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmo src/hopix/hopixInterpreter.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmo src/hopix/hopixInterpreter.ml
File "src/hopix/hopixInterpreter.ml", line 78, characters 10-21:
Warning 26: unused variable list_to_str.
File "src/hopix/hopixInterpreter.ml", line 116, characters 6-24:
Warning 26: unused variable print_record_value.
File "src/hopix/hopixInterpreter.ml", line 118, characters 6-17:
Warning 26: unused variable print_field.
File "src/hopix/hopixInterpreter.ml", line 114, characters 10-11:
Warning 11: this match case is unused.
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixLexer.cmo src/hopix/hopixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmo src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypechecker.cmo src/hopix/hopixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmi src/utilities/syntacticAnalysis.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopix.cmo src/hopix/hopix.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/userInput.ml > src/utilities/userInput.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/stdUserInput.ml > src/utilities/stdUserInput.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/stdUserInput.cmo src/utilities/stdUserInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/commandLineOptions.cmo src/commandLineOptions.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInitialization.cmo src/hopix/hopixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/userInput.cmo src/utilities/userInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/flap.cmo src/flap.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.ml > src/utilities/error.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.ml > src/utilities/position.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/position.cmx src/utilities/position.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/error.cmx src/utilities/error.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/options.cmx src/options.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/version.cmx src/version.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extStd.cmx src/utilities/extStd.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/languages.cmx src/common/languages.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/compilers.cmx src/common/compilers.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixAST.cmx src/hopix/hopixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.ml > src/hopix/memory.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/memory.cmx src/hopix/memory.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.ml > src/hopix/hopixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixParser.cmx src/hopix/hopixParser.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.ml > src/lib/pprint/PPrintCombinators.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.ml > src/lib/pprint/PPrintEngine.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintEngine.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.ml > src/lib/pprint/PPrintOCaml.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintCombinators.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrintOCaml.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrint.cmx src/lib/pprint/PPrint.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extPPrint.cmx src/utilities/extPPrint.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypes.cmx src/hopix/hopixTypes.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.ml > src/utilities/syntacticAnalysis.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmx src/hopix/hopixInterpreter.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmx src/hopix/hopixInterpreter.ml
File "src/hopix/hopixInterpreter.ml", line 78, characters 10-21:
Warning 26: unused variable list_to_str.
File "src/hopix/hopixInterpreter.ml", line 116, characters 6-24:
Warning 26: unused variable print_record_value.
File "src/hopix/hopixInterpreter.ml", line 118, characters 6-17:
Warning 26: unused variable print_field.
File "src/hopix/hopixInterpreter.ml", line 114, characters 10-11:
Warning 11: this match case is unused.
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixLexer.cmx src/hopix/hopixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmx src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypechecker.cmx src/hopix/hopixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmx src/utilities/syntacticAnalysis.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopix.cmx src/hopix/hopix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/stdUserInput.cmx src/utilities/stdUserInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/commandLineOptions.cmx src/commandLineOptions.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInitialization.cmx src/hopix/hopixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/userInput.cmx src/utilities/userInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/flap.cmx src/flap.ml
ocamlfind ocamlopt -linkpkg -package unix -package str src/utilities/position.cmx src/utilities/error.cmx src/options.cmx src/version.cmx src/commandLineOptions.cmx src/common/languages.cmx src/utilities/extStd.cmx src/common/compilers.cmx src/hopix/hopixAST.cmx src/hopix/memory.cmx src/hopix/hopixInterpreter.cmx src/hopix/hopixParser.cmx src/hopix/hopixLexer.cmx src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrint.cmx src/utilities/extPPrint.cmx src/hopix/hopixPrettyPrinter.cmx src/hopix/hopixTypes.cmx src/hopix/hopixTypechecker.cmx src/utilities/syntacticAnalysis.cmx src/hopix/hopix.cmx src/hopix/hopixInitialization.cmx src/utilities/stdUserInput.cmx src/utilities/userInput.cmx src/flap.cmx -o src/flap.native
ln -s flap.native flap
=> Je lance les tests.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make -C tests check
make[1]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests'
make -C ..
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2'
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/bad'
========================================================
In interpreter/bad
GOOD: 0 / 0

BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/bad'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/good'
========================================================
In interpreter/good
[ OK ]   comment1.hopix

INPUT:
val a := 1.
val b := `+ 1 1.
OUTPUT: 
a = 1
b = 2
EXPECTED: 
a = 1
b = 2
--------------------------------------------------------
[ OK ]   comment2.hopix

INPUT:
val x := `+ 1 1.
val x := `+ 1 2.
val x := 3.
OUTPUT: 
x = 2
x = 3
x = 3
EXPECTED: 
x = 2
x = 3
x = 3
--------------------------------------------------------
[ OK ]   comment4.hopix

INPUT:

OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   do1.hopix

INPUT:
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
OUTPUT: 
seq3 = <fun>
EXPECTED: 
seq3 = <fun>
--------------------------------------------------------
[ OK ]   do2.hopix

INPUT:
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
OUTPUT: 
seq3 = <fun>
EXPECTED: 
seq3 = <fun>
--------------------------------------------------------
[ OK ]   do3.hopix

INPUT:
val f := \y => val nothing := y ? { | _ => 1 }; 2.
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   do4.hopix

INPUT:
val f := \y => val nothing := 1; y ? { | _ => 2 }.
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   do.hopix

INPUT:
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
val f := \y => val nothing := y ? { | _ => 1 }; 2.
val f := \y => val nothing := 1; y ? { | _ => 2 }.
OUTPUT: 
seq3 = <fun>
seq3 = <fun>
f = <fun>
f = <fun>
EXPECTED: 
seq3 = <fun>
seq3 = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ OK ]   extern1.hopix

INPUT:
extern something : int.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   extern2.hopix

INPUT:
extern some_function : int -> (int -> int) -> int.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   extern.hopix

INPUT:
extern something : int.
extern some_function : int -> (int -> int) -> int.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   functions2.hopix

INPUT:
val f := \(x : int) => \(y : int) => (`+ x y : int).
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   functions3.hopix

INPUT:
val f := (\x => `+ x 1 : int -> int).
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   functions4.hopix

INPUT:
val g := \x => \y => `+ x y.
OUTPUT: 
g = <fun>
EXPECTED: 
g = <fun>
--------------------------------------------------------
[ OK ]   functions5.hopix

INPUT:
val g := \x => \y => `+ x y.
OUTPUT: 
g = <fun>
EXPECTED: 
g = <fun>
--------------------------------------------------------
[ OK ]   functions.hopix

INPUT:
val f := \x => \y => `+ x y.
val f := \(x : int) => \(y : int) => (`+ x y : int).
val f := (\x => `+ x 1 : int -> int).
val g := \x => \y => `+ x y.
val g := \x => \y => `+ x y.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
g = <fun>
g = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
g = <fun>
g = <fun>
--------------------------------------------------------
[ KO ]   -->  higherorderfind.hopix

INPUT:
type l := { N | I : int * l }.

val l := I (1, I (2, I (3, N))).

rec find k x l on_find on_error :=
  l ? {
  | N =>
    on_error k
  | I (y, ys) =>
    if x = y then on_find k else find (k + 1) x ys on_find on_error fi
  }.

val x := find 0 1 l (\x => true) (\x => false).

val y := find 0 0 l (\x => x) (\x => 0 - x).
OUTPUT: 
Failure("Mismatch failure")
EXPECTED: 
l = I(1, I(2, I(3, N)))
find = <fun>
x = true
y = -3
--------------------------------------------------------
[ OK ]   infix1.hopix

INPUT:
val `++ := \x => \y => x.
OUTPUT: 
`++ = <fun>
EXPECTED: 
`++ = <fun>
--------------------------------------------------------
[ OK ]   infix2.hopix

INPUT:
val `++ := \x => \y => y.
val z := `++ 0 1.
OUTPUT: 
`++ = <fun>
z = 1
EXPECTED: 
`++ = <fun>
z = 1
--------------------------------------------------------
[ OK ]   infix3.hopix

INPUT:
val `++ := \x => \y => x.
val k := `++ 0 1.
OUTPUT: 
`++ = <fun>
k = 0
EXPECTED: 
`++ = <fun>
k = 0
--------------------------------------------------------
[ OK ]   infix4.hopix

INPUT:
val `eats := \x => \y => x.
OUTPUT: 
`eats = <fun>
EXPECTED: 
`eats = <fun>
--------------------------------------------------------
[ OK ]   infix5.hopix

INPUT:
val wow := \cat => \mouse => `eats cat mouse.
OUTPUT: 
wow = <fun>
EXPECTED: 
wow = <fun>
--------------------------------------------------------
[ OK ]   infix6.hopix

INPUT:
val apply := \`op => \x => \y => `op x y.
OUTPUT: 
apply = <fun>
EXPECTED: 
apply = <fun>
--------------------------------------------------------
[ OK ]   infix7.hopix

INPUT:
val apply := \`op => \x => \y => `op x y.
OUTPUT: 
apply = <fun>
EXPECTED: 
apply = <fun>
--------------------------------------------------------
[ OK ]   infix.hopix

INPUT:
val `++ := \x => \y => x.
val z := `++ 0 0.
val k := `++ 0 0.
val `eats := \x => \y => x.
val wow := \cat => \mouse => `eats cat mouse.
val apply := \`op => \x => \y => `op x y.
val apply := \`op => \x => \y => `op x y.
OUTPUT: 
`++ = <fun>
z = 0
k = 0
`eats = <fun>
wow = <fun>
apply = <fun>
apply = <fun>
EXPECTED: 
`++ = <fun>
z = 0
k = 0
`eats = <fun>
wow = <fun>
apply = <fun>
apply = <fun>
--------------------------------------------------------
[ KO ]   -->  lexchar10.hopix

INPUT:
val x := '\r'.
OUTPUT: 
x = \r
EXPECTED: 
x = '\r'
--------------------------------------------------------
[ KO ]   -->  lexchar11.hopix

INPUT:
val x := '\000'.
OUTPUT: 
x = \000
EXPECTED: 
x = '\000'
--------------------------------------------------------
[ KO ]   -->  lexchar12.hopix

INPUT:
val x := '\001'.
OUTPUT: 
x = \001
EXPECTED: 
x = '\001'
--------------------------------------------------------
[ KO ]   -->  lexchar13.hopix

INPUT:
val x := '\255'.
OUTPUT: 
x = \255
EXPECTED: 
x = '\255'
--------------------------------------------------------
[ KO ]   -->  lexchar14.hopix

INPUT:
val x := '\255'.
OUTPUT: 
x = \255
EXPECTED: 
x = '\255'
--------------------------------------------------------
[ KO ]   -->  lexchar15.hopix

INPUT:
val x := '\171'.
OUTPUT: 
x = \171
EXPECTED: 
x = '\171'
--------------------------------------------------------
[ KO ]   -->  lexchar16.hopix

INPUT:
val x := '\018'.
OUTPUT: 
x = \018
EXPECTED: 
x = '\018'
--------------------------------------------------------
[ KO ]   -->  lexchar17.hopix

INPUT:
val x := '\204'.
OUTPUT: 
x = \204
EXPECTED: 
x = '\204'
--------------------------------------------------------
[ KO ]   -->  lexchar18.hopix

INPUT:
val x := '\204'.
OUTPUT: 
x = \204
EXPECTED: 
x = '\204'
--------------------------------------------------------
[ KO ]   -->  lexchar1.hopix

INPUT:
val x := 'a'.
OUTPUT: 
x = a
EXPECTED: 
x = 'a'
--------------------------------------------------------
[ KO ]   -->  lexchar2.hopix

INPUT:
val x := 'A'.
OUTPUT: 
x = A
EXPECTED: 
x = 'A'
--------------------------------------------------------
[ KO ]   -->  lexchar3.hopix

INPUT:
val x := '*'.
OUTPUT: 
x = *
EXPECTED: 
x = '*'
--------------------------------------------------------
[ KO ]   -->  lexchar4.hopix

INPUT:
val x := '@'.
OUTPUT: 
x = @
EXPECTED: 
x = '@'
--------------------------------------------------------
[ KO ]   -->  lexchar5.hopix

INPUT:
val x := '\\'.
OUTPUT: 
x = \\
EXPECTED: 
x = '\\'
--------------------------------------------------------
[ KO ]   -->  lexchar6.hopix

INPUT:
val x := '\''.
OUTPUT: 
x = \'
EXPECTED: 
x = '\''
--------------------------------------------------------
[ KO ]   -->  lexchar7.hopix

INPUT:
val x := '\n'.
OUTPUT: 
x = \n
EXPECTED: 
x = '\n'
--------------------------------------------------------
[ KO ]   -->  lexchar8.hopix

INPUT:
val x := '\t'.
OUTPUT: 
x = \t
EXPECTED: 
x = '\t'
--------------------------------------------------------
[ KO ]   -->  lexchar9.hopix

INPUT:
val x := '\b'.
OUTPUT: 
x = \b
EXPECTED: 
x = '\b'
--------------------------------------------------------
[ KO ]   -->  lexchar.hopix

INPUT:
val x := 'a'.
val x := 'A'.
val x := '*'.
val x := '@'.
val x := '\\'.
val x := '\''.
val x := '\n'.
val x := '\t'.
val x := '\b'.
val x := '\r'.
val x := '\000'.
val x := '\001'.
val x := '\255'.
val x := '\255'.
val x := '\171'.
val x := '\018'.
val x := '\204'.
val x := '\204'.
OUTPUT: 
x = a
x = A
x = *
x = @
x = \\
x = \'
x = \n
x = \t
x = \b
x = \r
x = \000
x = \001
x = \255
x = \255
x = \171
x = \018
x = \204
x = \204
EXPECTED: 
x = 'a'
x = 'A'
x = '*'
x = '@'
x = '\\'
x = '\''
x = '\n'
x = '\t'
x = '\b'
x = '\r'
x = '\000'
x = '\001'
x = '\255'
x = '\255'
x = '\171'
x = '\018'
x = '\204'
x = '\204'
--------------------------------------------------------
[ OK ]   lexnum1.hopix

INPUT:
val x := 0.
OUTPUT: 
x = 0
EXPECTED: 
x = 0
--------------------------------------------------------
[ OK ]   lexnum2.hopix

INPUT:
val x := 1234567890.
OUTPUT: 
x = 1234567890
EXPECTED: 
x = 1234567890
--------------------------------------------------------
[ OK ]   lexnum3.hopix

INPUT:
val x := 233495534.
OUTPUT: 
x = 233495534
EXPECTED: 
x = 233495534
--------------------------------------------------------
[ OK ]   lexnum4.hopix

INPUT:
val x := 233495534.
OUTPUT: 
x = 233495534
EXPECTED: 
x = 233495534
--------------------------------------------------------
[ OK ]   lexnum5.hopix

INPUT:
val x := 305419896.
OUTPUT: 
x = 305419896
EXPECTED: 
x = 305419896
--------------------------------------------------------
[ OK ]   lexnum6.hopix

INPUT:
val x := 559038737.
OUTPUT: 
x = 559038737
EXPECTED: 
x = 559038737
--------------------------------------------------------
[ OK ]   lexnum7.hopix

INPUT:
val x := 42.
OUTPUT: 
x = 42
EXPECTED: 
x = 42
--------------------------------------------------------
[ OK ]   lexnum.hopix

INPUT:
val x := 0.
val x := 1234567890.
val x := 233495534.
val x := 233495534.
val x := 305419896.
val x := 559038737.
val x := 42.
val x := 42.
OUTPUT: 
x = 0
x = 1234567890
x = 233495534
x = 233495534
x = 305419896
x = 559038737
x = 42
x = 42
EXPECTED: 
x = 0
x = 1234567890
x = 233495534
x = 233495534
x = 305419896
x = 559038737
x = 42
x = 42
--------------------------------------------------------
[ KO ]   -->  lexstring1.hopix

INPUT:
val x := "".
OUTPUT: 
x = 
EXPECTED: 
x = ""
--------------------------------------------------------
[ KO ]   -->  lexstring2.hopix

INPUT:
val x := "abc".
OUTPUT: 
x = abc
EXPECTED: 
x = "abc"
--------------------------------------------------------
[ KO ]   -->  lexstring3.hopix

INPUT:
val x := "**".
OUTPUT: 
x = **
EXPECTED: 
x = "**"
--------------------------------------------------------
[ KO ]   -->  lexstring4.hopix

INPUT:
val x := "{*".
OUTPUT: 
x = {*
EXPECTED: 
x = "{*"
--------------------------------------------------------
[ KO ]   -->  lexstring5.hopix

INPUT:
val x := "*}".
OUTPUT: 
x = *}
EXPECTED: 
x = "*}"
--------------------------------------------------------
[ KO ]   -->  lexstring6.hopix

INPUT:
val x := "a'a".
OUTPUT: 
x = a'a
EXPECTED: 
x = "a'a"
--------------------------------------------------------
[ KO ]   -->  lexstring.hopix

INPUT:
val x := "".
val x := "abc".
val x := "**".
val x := "{*".
val x := "*}".
val x := "a'a".
OUTPUT: 
x = 
x = abc
x = **
x = {*
x = *}
x = a'a
EXPECTED: 
x = ""
x = "abc"
x = "**"
x = "{*"
x = "*}"
x = "a'a"
--------------------------------------------------------
[ KO ]   -->  list.hopix

INPUT:
type list := { Cons : int * list | Nil }.
rec
 map :=
  \f =>
    \l =>
      (l ? { | Nil => Nil | Cons (x, xs) => Cons (f x, map f xs) }
      : list).
rec
 append :=
  \l1 =>
    \l2 =>
      (l1 ? { | Nil => l2 | Cons (x, xs) => Cons (x, append xs l2) }
      : list).
rec
 sum :=
  \l1 =>
    \l2 =>
      (l1 ?
      {
      | Nil => l2 ? { | _ => l2 }
      | Cons (x, xs) =>
        l2 ? { | Cons (y, ys) => Cons (`+ x y, sum xs ys) | _ => l1 }
      }
      : list).

val a := Cons (1, Cons (2, Nil)).
val b := Cons (3, Cons (4, Cons (5, Nil))).

val ab := append a b.
val sumab := sum a a.
val shifta := map (\x => x + 1) a.
val complex := sum (map (\x => x * 2 + 1) (append b (append ab a))) a.
OUTPUT: 
Failure("Mismatch failure")
EXPECTED: 
map = <fun>
append = <fun>
sum = <fun>
a = Cons(1, Cons(2, Nil))
b = Cons(3, Cons(4, Cons(5, Nil)))
ab = Cons(1, Cons(2, Cons(3, Cons(4, Cons(..., ...)))))
sumab = Cons(2, Cons(4, Nil))
shifta = Cons(2, Cons(3, Nil))
complex = Cons(8, Cons(11, Cons(11, Cons(3, Cons(..., ...)))))
--------------------------------------------------------
[ OK ]   localdef1.hopix

INPUT:
val x := val y := 1; val z := 2; `+ y z.
OUTPUT: 
x = 3
EXPECTED: 
x = 3
--------------------------------------------------------
[ OK ]   localdef2.hopix

INPUT:
val x := `+ 1 (val y := 1; val z := 2; `+ y z).
OUTPUT: 
x = 4
EXPECTED: 
x = 4
--------------------------------------------------------
[ OK ]   localdef3.hopix

INPUT:
val x :=
  val y := val z := 1; `* 2 z; val t := val u := 2; `* 2 u; `* y t.
OUTPUT: 
x = 8
EXPECTED: 
x = 8
--------------------------------------------------------
[ OK ]   localdef4.hopix

INPUT:
val even :=
  rec
     even := \x => if `= x 0 then true else odd (`- x 1) fi
    and
     odd := \x => if `= x 0 then false else even (`- x 1) fi;
  even 10.
OUTPUT: 
even = true
EXPECTED: 
even = true
--------------------------------------------------------
[ OK ]   localdef.hopix

INPUT:
val x := val y := 1; val z := 2; `+ y z.
val x := `+ 1 (val y := 1; val z := 2; `+ y z).
val x :=
  val y := val z := 1; `* 2 z; val t := val u := 2; `* 2 u; `* y t.
val even :=
  rec
     even := \x => if `= x 0 then true else odd (`- x 1) fi
    and
     odd := \x => if `= x 0 then false else even (`- x 1) fi;
  even x.
OUTPUT: 
x = 3
x = 4
x = 8
even = true
EXPECTED: 
x = 3
x = 4
x = 8
even = true
--------------------------------------------------------
[ OK ]   match11.hopix

INPUT:
type enum := { A | B | C | D }.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  match12.hopix

INPUT:
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val x := f D + f C + f B + f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 10
--------------------------------------------------------
[ KO ]   -->  match13.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f D + f C + f B + f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 10
--------------------------------------------------------
[ KO ]   -->  match14.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f D + f C * f B - f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 11
--------------------------------------------------------
[ KO ]   -->  match15.hopix

INPUT:
val f := \x => \y => x ? { | A => y ? { | B => C } }.
val x := f A B.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = C
--------------------------------------------------------
[ OK ]   match1.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => \y => x ? { | A => y ? { | B => C } }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ OK ]   match21.hopix

INPUT:
type enum := { A | B | C | D }.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  match22.hopix

INPUT:
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val x := f A + f C * f B - f D.

OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match23.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f A + f C * f B - f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 7
--------------------------------------------------------
[ KO ]   -->  match24.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f A + f C * f B - f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 7
--------------------------------------------------------
[ KO ]   -->  match25.hopix

INPUT:
val f := \x => \y => x ? { | A => y ? { | B => C } }.
val x := f A B.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = C
--------------------------------------------------------
[ OK ]   match2.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => \y => x ? { | A => y ? { | B => C } }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ KO ]   -->  match31.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val x := f A + f B - f C * f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
--------------------------------------------------------
[ KO ]   -->  match32.hopix

INPUT:
val f := \x => x ? { | (A | B | C | D) => 1 }.
val x := f A + f B - f C * f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
--------------------------------------------------------
[ KO ]   -->  match33.hopix

INPUT:
val f := \x => x ? { | (A | B | C | D) => 1 }.
val x := f A + f B - f C * f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
--------------------------------------------------------
[ KO ]   -->  match34.hopix

INPUT:
val f := \x => x ? { | (A & B & C & D) => 1 | _ => 0 }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 0
--------------------------------------------------------
[ KO ]   -->  match35.hopix

INPUT:
val f := \x => x ? { | (A & B & C & D) => 1 | _ => 0 }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 0
--------------------------------------------------------
[ KO ]   -->  match36.hopix

INPUT:
val f := \x => x ? { | (A & B & C & D) => 1 | _ => 0 }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 0
--------------------------------------------------------
[ KO ]   -->  match37.hopix

INPUT:
val f := \x => x ? { | ((A | B) & y & _) => y | C => A }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = A
--------------------------------------------------------
[ KO ]   -->  match38.hopix

INPUT:
val f := \x => x ? { | (A | (B & y) | _) => 1 | C => 0 }.
val x := f A.
val y := f B.
val z := f C.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
y = 1
z = 1
--------------------------------------------------------
[ OK ]   match3.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val f := \x => x ? { | (A & B & C & D) => 1 }.
val f := \x => x ? { | (A & B & C & D) => 1 }.
val f := \x => x ? { | (A & B & C & D) => 1 }.
val f := \x => x ? { | ((A | B) & y & (B | C) & _) => y }.
val f := \x => x ? { | (A | (B & y) | _) => 1 }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ OK ]   match41.hopix

INPUT:
type record := { aaa : int ; bbb : int }.

OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  match42.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match43.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match44.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match45.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ OK ]   match4.hopix

INPUT:
type record := { aaa : int ; bbb : int }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ KO ]   -->  merge.hopix

INPUT:
type nat := { Z | S : nat }.

rec gt x y :=
  x ? { Z => false | S (x) =>
    y ? { Z => true | S (y) =>
      gt x y
    }
  }.

rec int2nat n :=
  if n = 0 then Z else S (int2nat (n - 1)) fi.

rec nat2int n :=
  n ? { Z => 0 | S (k) => 1 + nat2int k }.

type ilist := { I : int * ilist | N }.

type list := { Cons : nat * list | Nil }.

rec i2l l :=
  l ? { N => Nil | I (x, l) => Cons (int2nat x, i2l l) }.

rec l2i l :=
  l ? { Nil => N | Cons (x, l) => I (nat2int x, l2i l) }.

rec merge l1 l2 :=
  l1 ? { Nil => l2 | Cons (x, xs) =>
  l2 ? { Nil => l1 | Cons (y, ys) =>
    if gt x y then
      Cons (y, merge l1 ys)
    else
      Cons (x, merge xs l2)
    fi
  }}.

type pair := { Pair : list * list }.

val bnot b :=
 if b then false else true fi.

rec split turn l :=
  l ? { Nil => Pair (Nil, Nil) | Cons (x, xs) =>
     split (bnot turn) xs ? Pair (a, b) =>
     if turn then Pair (Cons (x, a), b) else Pair (a, Cons (x, b)) fi
  }.

rec sort l :=
  l ? {
  | Nil => Nil
  | Cons (x, Nil) => Cons (x, Nil)
  | _ =>
    split true l ? Pair (a, b) =>
    merge (sort a) (sort b)
  }.


val l1 := l2i (sort (i2l (I (1, I (0, I (5, I (3, I (4, I (1, I (9, N)))))))))).

type o := { None | Some : int }.

rec take n l :=
  l ? {
  | N => None
  | I (x, xs) =>
    if n = 0 then Some (x) else take (n - 1) xs fi
  }.

val x6 := take 6 l1.
val x5 := take 5 l1.
val x4 := take 4 l1.
val x3 := take 3 l1.
val x2 := take 2 l1.
val x1 := take 1 l1.
val x0 := take 0 l1.
OUTPUT: 
Failure("Mismatch failure")
EXPECTED: 
gt = <fun>
int2nat = <fun>
nat2int = <fun>
i2l = <fun>
l2i = <fun>
merge = <fun>
bnot = <fun>
split = <fun>
sort = <fun>
l1 = I(0, I(1, I(1, I(3, I(..., ...)))))
take = <fun>
x6 = Some(9)
x5 = Some(5)
x4 = Some(4)
x3 = Some(3)
x2 = Some(1)
x1 = Some(1)
x0 = Some(0)
--------------------------------------------------------
[ KO ]   -->  mutrecfun.hopix

INPUT:
rec
 odd :=
  \(n : int) =>
    (if `= n 0 then false
    else if `= n 1 then true else even (`- n 1) fi fi
    : int)
and even :=
  \(n : int) =>
    (if `= n 0 then true
    else if `= n 1 then false else odd (`- n 1) fi fi
    : int).

val x := even 42.
OUTPUT: 
File "src/hopix/hopixInterpreter.ml", line 312, characters 8-14: Assertion failed
EXPECTED: 
odd = <fun>
even = <fun>
x = true
--------------------------------------------------------
[ OK ]   partial.hopix

INPUT:
val f x :=
   val y := x * 2;
   \z => x + y + z.

val z := f 1 2.
val g := f 8.
val t := g 3.
val u := g 4.

OUTPUT: 
f = <fun>
z = 5
g = <fun>
t = 27
u = 28
EXPECTED: 
f = <fun>
z = 5
g = <fun>
t = 27
u = 28
--------------------------------------------------------
[ OK ]   pri_app1.hopix

INPUT:
val f x := x * x.
val a := 1.
val b := 3.
val x := `+ (f a) b.
OUTPUT: 
f = <fun>
a = 1
b = 3
x = 4
EXPECTED: 
f = <fun>
a = 1
b = 3
x = 4
--------------------------------------------------------
[ KO ]   -->  pri_app2.hopix

INPUT:
val f x := x * x.
val a := { b := 3 }.
val x := f a#b.
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
a = { b = 3 }
x = 9
--------------------------------------------------------
[ OK ]   pri_app3.hopix

INPUT:
val f g x := g x * x.
val a := 1.
val g x := 3 + x.
val x := f g a.
OUTPUT: 
f = <fun>
a = 1
g = <fun>
x = 4
EXPECTED: 
f = <fun>
a = 1
g = <fun>
x = 4
--------------------------------------------------------
[ OK ]   pri_arith1.hopix

INPUT:
val x := `+ (`+ 1 2) 3.
OUTPUT: 
x = 6
EXPECTED: 
x = 6
--------------------------------------------------------
[ OK ]   pri_arith2.hopix

INPUT:
val x := `+ (`- (`- (`+ 1 2) 3) 4) 5.
OUTPUT: 
x = 1
EXPECTED: 
x = 1
--------------------------------------------------------
[ OK ]   pri_arith3.hopix

INPUT:
val x := `* (`* 1 2) 3.
OUTPUT: 
x = 6
EXPECTED: 
x = 6
--------------------------------------------------------
[ OK ]   pri_arith4.hopix

INPUT:
val x := `/ (`/ 1 2) 3.
OUTPUT: 
x = 0
EXPECTED: 
x = 0
--------------------------------------------------------
[ OK ]   pri_arith5.hopix

INPUT:
val x := `* (`/ (`/ (`* 1 2) 3) 4) 5.
OUTPUT: 
x = 0
EXPECTED: 
x = 0
--------------------------------------------------------
[ OK ]   pri_arith6.hopix

INPUT:
val x := `- (`+ 1 (`* 2 3)) 4.
OUTPUT: 
x = 3
EXPECTED: 
x = 3
--------------------------------------------------------
[ OK ]   pri_arith7.hopix

INPUT:
val x := `+ (`- (`+ 1 (`* 2 3)) (`/ 4 5)) 6.
OUTPUT: 
x = 13
EXPECTED: 
x = 13
--------------------------------------------------------
[ OK ]   pri_arith8.hopix

INPUT:
val x := `* (`+ 1 2) 3.
OUTPUT: 
x = 9
EXPECTED: 
x = 9
--------------------------------------------------------
[ OK ]   pri_arith.hopix

INPUT:
val x := `+ (`+ 1 2) 3.
val x := `+ (`- (`- (`+ 1 2) 3) 4) 5.
val x := `* (`* 1 2) 3.
val x := `/ (`/ 1 2) 3.
val x := `* (`/ (`/ (`* 1 2) 3) 4) 5.
val x := `- (`+ 1 (`* 2 3)) 4.
val x := `+ (`- (`+ 1 (`* 2 3)) (`/ 4 5)) 6.
val x := `* (`+ 1 2) 3.
OUTPUT: 
x = 6
x = 1
x = 6
x = 0
x = 0
x = 3
x = 13
x = 9
EXPECTED: 
x = 6
x = 1
x = 6
x = 0
x = 0
x = 3
x = 13
x = 9
--------------------------------------------------------
[ OK ]   pri_comp1.hopix

INPUT:
val x := `= 2 (`+ 1 1).
OUTPUT: 
x = true
EXPECTED: 
x = true
--------------------------------------------------------
[ KO ]   -->  pri_comp2.hopix

INPUT:
val x := true || true && true && true.
OUTPUT: 
HopixInterpreter.Environment.UnboundIdentifier(_)
EXPECTED: 
x = true
--------------------------------------------------------
[ KO ]   -->  pri_comp3.hopix

INPUT:
val x := 1 + 1 < 2 + 2 && 4 = 7.

OUTPUT: 
HopixInterpreter.Environment.UnboundIdentifier(_)
EXPECTED: 
x = false
--------------------------------------------------------
[ OK ]   pri_infix.hopix

INPUT:
val `op x y := x - y * x.
val x := 1 = (`op (1 `op` 2) (`+ 3 3)). 
OUTPUT: 
`op = <fun>
x = false
EXPECTED: 
`op = <fun>
x = false
--------------------------------------------------------
[ KO ]   -->  pri_larrow1.hopix

INPUT:
val t := { a := 0 }.
val x := t#a <- `+ 1 2.
val z := t#a.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = 3 }
x = ()
z = 3
--------------------------------------------------------
[ KO ]   -->  pri_larrow2.hopix

INPUT:
val t := { a := false }.
val x := t#a <- true || false.
val y := t#a.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = true }
x = ()
y = true
--------------------------------------------------------
[ KO ]   -->  pri_larrow3.hopix

INPUT:
val t := { a := 3 }.
val x := t#a <- (t ? { | _ => 1 }).
val y := t#a.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = 1 }
x = ()
y = 1
--------------------------------------------------------
[ OK ]   pri_qmark1.hopix

INPUT:
val x := 2.
val y := `* x (x ? { | _ => 3 }).
OUTPUT: 
x = 2
y = 6
EXPECTED: 
x = 2
y = 6
--------------------------------------------------------
[ KO ]   -->  pri_qmark2.hopix

INPUT:
val x := { a := 1 }.
val y := x#a ? { | z => z + 2 }.
OUTPUT: 
Failure("salut")
EXPECTED: 
x = { a = 1 }
y = 3
--------------------------------------------------------
[ OK ]   pri_rarrow1.hopix

INPUT:
val x := \x => `+ x x.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow2.hopix

INPUT:
val x := \x => x && x.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow3.hopix

INPUT:
val x := \x => x#a <- 1.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow4.hopix

INPUT:
val x := val f := \x => x; f.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow5.hopix

INPUT:
val x := val f := \y => y ? { | _ => 1 }; f 1.
OUTPUT: 
x = 1
EXPECTED: 
x = 1
--------------------------------------------------------
[ OK ]   pri_rarrow.hopix

INPUT:
val x := \x => `+ x x.
val x := \x => x && x.
val x := \x => x#a <- 1.
val x := val f := \x => x; f.
val x := val f := \y => y ? { | _ => 1 }; f 1.
OUTPUT: 
x = <fun>
x = <fun>
x = <fun>
x = <fun>
x = 1
EXPECTED: 
x = <fun>
x = <fun>
x = <fun>
x = <fun>
x = 1
--------------------------------------------------------
[ OK ]   pri_scolon1.hopix

INPUT:
val x := val y := `+ 1 1; `+ y y.
OUTPUT: 
x = 4
EXPECTED: 
x = 4
--------------------------------------------------------
[ KO ]   -->  pri_scolon2.hopix

INPUT:
val x := val y := true; y || false.
OUTPUT: 
HopixInterpreter.Environment.UnboundIdentifier(_)
EXPECTED: 
x = true
--------------------------------------------------------
[ OK ]   pri_scolon3.hopix

INPUT:
val x := val y := 1; y ? { | _ => 2 }.
OUTPUT: 
x = 2
EXPECTED: 
x = 2
--------------------------------------------------------
[ KO ]   -->  pri_sharp1.hopix

INPUT:
val t := { a := { b := 42 } }.
val x := t#a#b.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = { b = 42 } }
x = 42
--------------------------------------------------------
[ KO ]   -->  pri_sharp2.hopix

INPUT:
val t := { a := 3 }.
val x := `* t#a 3.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
t = { a = 3 }
x = 9
--------------------------------------------------------
[ KO ]   -->  pri_sharp.hopix

INPUT:
val t := { a := { b := 3 } }.
val x := t#a#b.
val u := { a := t#a#b }.
val x := `* u#a 3.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
t = { a = { b = 3 } }
x = 3
u = { a = 3 }
x = 9
--------------------------------------------------------
[ KO ]   -->  recfun.hopix

INPUT:
rec
 fact :=
  \(n : int) =>
    (if `= n 0 then 1 else `* n (fact (`- n 1)) fi : int).

val hundredandtwenty := fact 5.
OUTPUT: 
File "src/hopix/hopixInterpreter.ml", line 312, characters 8-14: Assertion failed
EXPECTED: 
fact = <fun>
hundredandtwenty = 120
--------------------------------------------------------
[ OK ]   record1.hopix

INPUT:
type point := { x : int ; y : int }.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  record2.hopix

INPUT:
val p := { x := 2; y := 3 }.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 2; y = 3 }
--------------------------------------------------------
[ KO ]   -->  record3.hopix

INPUT:
val p := { x := 3 + 3 }.
val y := p#x.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 6 }
y = 6
--------------------------------------------------------
[ KO ]   -->  record4.hopix

INPUT:
val p := { x := 0 }.
val u := p#x <- 3.
val z := p#x.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 3 }
u = ()
z = 3
--------------------------------------------------------
[ KO ]   -->  record.hopix

INPUT:
type point := { x : int ; y : int }.
val p := { x := 2; y := 3 }.
val y := p#x.
val u := p#x <- 3.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 3; y = 3 }
y = 2
u = ()
--------------------------------------------------------
GOOD: 68 / 134
BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/good'
--------------------------------------------------------
Global results:
BAD:   0 / 0
GOOD:  68 / 134
--------------------------------------------------------
make[1]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests'=> J'ai trouvé une archive.
=> Je la décompresse.
flap-uzenat-elouraoui-15.2/
flap-uzenat-elouraoui-15.2/myocamlbuild_config.ml
flap-uzenat-elouraoui-15.2/Makefile.local
flap-uzenat-elouraoui-15.2/src/
flap-uzenat-elouraoui-15.2/src/version.ml
flap-uzenat-elouraoui-15.2/src/common/
flap-uzenat-elouraoui-15.2/src/common/compilers.ml
flap-uzenat-elouraoui-15.2/src/common/languages.ml
flap-uzenat-elouraoui-15.2/src/options.ml
flap-uzenat-elouraoui-15.2/src/hopix/
flap-uzenat-elouraoui-15.2/src/hopix/memory.mli
flap-uzenat-elouraoui-15.2/src/hopix/hopixTypechecker.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixInterpreter.ml
flap-uzenat-elouraoui-15.2/src/hopix/memory.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixLexer.mll
flap-uzenat-elouraoui-15.2/src/hopix/hopixTypeInferenceEngine.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixAST.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixPrettyPrinter.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixParser.mly
flap-uzenat-elouraoui-15.2/src/hopix/hopix.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixTypes.ml
flap-uzenat-elouraoui-15.2/src/hopix/hopixInitialization.ml
flap-uzenat-elouraoui-15.2/src/lib/
flap-uzenat-elouraoui-15.2/src/lib/pprint/
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintEngine.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/LICENSE
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintOCaml.mli
flap-uzenat-elouraoui-15.2/src/lib/pprint/CHANGES
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintRenderer.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintEngine.mli
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrint.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/AUTHORS
flap-uzenat-elouraoui-15.2/src/lib/pprint/README
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintCombinators.ml
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintCombinators.mli
flap-uzenat-elouraoui-15.2/src/lib/pprint/Makefile
flap-uzenat-elouraoui-15.2/src/lib/pprint/PPrintOCaml.ml
flap-uzenat-elouraoui-15.2/src/flap.ml
flap-uzenat-elouraoui-15.2/src/utilities/
flap-uzenat-elouraoui-15.2/src/utilities/userInput.ml
flap-uzenat-elouraoui-15.2/src/utilities/position.ml
flap-uzenat-elouraoui-15.2/src/utilities/error.ml
flap-uzenat-elouraoui-15.2/src/utilities/syntacticAnalysis.ml
flap-uzenat-elouraoui-15.2/src/utilities/position.mli
flap-uzenat-elouraoui-15.2/src/utilities/error.mli
flap-uzenat-elouraoui-15.2/src/utilities/extPPrint.ml
flap-uzenat-elouraoui-15.2/src/utilities/syntacticAnalysis.mli
flap-uzenat-elouraoui-15.2/src/utilities/stdUserInput.ml
flap-uzenat-elouraoui-15.2/src/utilities/option.ml
flap-uzenat-elouraoui-15.2/src/utilities/extStd.ml
flap-uzenat-elouraoui-15.2/src/commandLineOptions.ml
flap-uzenat-elouraoui-15.2/_tags
flap-uzenat-elouraoui-15.2/Makefile.generic
flap-uzenat-elouraoui-15.2/Makefile.config
flap-uzenat-elouraoui-15.2/Makefile
=> Je compile.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
ocamlfind ocamldep -package unix -package str -modules src/flap.ml > src/flap.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/commandLineOptions.ml > src/commandLineOptions.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/options.ml > src/options.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.mli > src/utilities/error.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.mli > src/utilities/position.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/position.cmi src/utilities/position.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/error.cmi src/utilities/error.mli
ocamlfind ocamldep -package unix -package str -modules src/version.ml > src/version.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/options.cmo src/options.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/version.cmo src/version.ml
ocamlfind ocamldep -package unix -package str -modules src/common/compilers.ml > src/common/compilers.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extStd.ml > src/utilities/extStd.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/common/languages.ml > src/common/languages.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extStd.cmo src/utilities/extStd.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/languages.cmo src/common/languages.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInitialization.ml > src/hopix/hopixInitialization.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/compilers.cmo src/common/compilers.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopix.ml > src/hopix/hopix.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixAST.ml > src/hopix/hopixAST.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixInterpreter.ml > src/hopix/hopixInterpreter.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixAST.cmo src/hopix/hopixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.mli > src/hopix/memory.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/memory.cmi src/hopix/memory.mli
/usr/bin/ocamllex -q src/hopix/hopixLexer.mll
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixLexer.ml > src/hopix/hopixLexer.ml.depends
menhir --raw-depend --ocamldep 'ocamlfind ocamldep -modules' src/hopix/hopixParser.mly > src/hopix/hopixParser.mly.depends
menhir --ocamlc 'ocamlfind ocamlc -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint' --explain --infer src/hopix/hopixParser.mly
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.mli > src/hopix/hopixParser.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixParser.cmi src/hopix/hopixParser.mli
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixPrettyPrinter.ml > src/hopix/hopixPrettyPrinter.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/extPPrint.ml > src/utilities/extPPrint.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrint.ml > src/lib/pprint/PPrint.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.mli > src/lib/pprint/PPrintCombinators.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.mli > src/lib/pprint/PPrintEngine.mli.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintRenderer.ml > src/lib/pprint/PPrintRenderer.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintRenderer.cmo src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintEngine.cmi src/lib/pprint/PPrintEngine.mli
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.mli > src/lib/pprint/PPrintOCaml.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintCombinators.cmi src/lib/pprint/PPrintCombinators.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintOCaml.cmi src/lib/pprint/PPrintOCaml.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrint.cmo src/lib/pprint/PPrint.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extPPrint.cmo src/utilities/extPPrint.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypechecker.ml > src/hopix/hopixTypechecker.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixTypes.ml > src/hopix/hopixTypes.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypes.cmo src/hopix/hopixTypes.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.mli > src/utilities/syntacticAnalysis.mli.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmo src/hopix/hopixInterpreter.ml
+ ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmo src/hopix/hopixInterpreter.ml
File "src/hopix/hopixInterpreter.ml", line 78, characters 10-21:
Warning 26: unused variable list_to_str.
File "src/hopix/hopixInterpreter.ml", line 116, characters 6-24:
Warning 26: unused variable print_record_value.
File "src/hopix/hopixInterpreter.ml", line 118, characters 6-17:
Warning 26: unused variable print_field.
File "src/hopix/hopixInterpreter.ml", line 114, characters 10-11:
Warning 11: this match case is unused.
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixLexer.cmo src/hopix/hopixLexer.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmo src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypechecker.cmo src/hopix/hopixTypechecker.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmi src/utilities/syntacticAnalysis.mli
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopix.cmo src/hopix/hopix.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/userInput.ml > src/utilities/userInput.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/stdUserInput.ml > src/utilities/stdUserInput.ml.depends
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/stdUserInput.cmo src/utilities/stdUserInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/commandLineOptions.cmo src/commandLineOptions.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInitialization.cmo src/hopix/hopixInitialization.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/userInput.cmo src/utilities/userInput.ml
ocamlfind ocamlc -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/flap.cmo src/flap.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/error.ml > src/utilities/error.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/utilities/position.ml > src/utilities/position.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/position.cmx src/utilities/position.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/error.cmx src/utilities/error.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/options.cmx src/options.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/version.cmx src/version.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extStd.cmx src/utilities/extStd.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/languages.cmx src/common/languages.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/common -I src -I src/hopix -I src/utilities -I src/lib/pprint -o src/common/compilers.cmx src/common/compilers.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixAST.cmx src/hopix/hopixAST.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/memory.ml > src/hopix/memory.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/memory.cmx src/hopix/memory.ml
ocamlfind ocamldep -package unix -package str -modules src/hopix/hopixParser.ml > src/hopix/hopixParser.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixParser.cmx src/hopix/hopixParser.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintCombinators.ml > src/lib/pprint/PPrintCombinators.ml.depends
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintEngine.ml > src/lib/pprint/PPrintEngine.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintRenderer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintEngine.ml
ocamlfind ocamldep -package unix -package str -modules src/lib/pprint/PPrintOCaml.ml > src/lib/pprint/PPrintOCaml.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintCombinators.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrintOCaml.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/lib/pprint -I src -I src/common -I src/hopix -I src/utilities -o src/lib/pprint/PPrint.cmx src/lib/pprint/PPrint.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/extPPrint.cmx src/utilities/extPPrint.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypes.cmx src/hopix/hopixTypes.ml
ocamlfind ocamldep -package unix -package str -modules src/utilities/syntacticAnalysis.ml > src/utilities/syntacticAnalysis.ml.depends
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmx src/hopix/hopixInterpreter.ml
+ ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInterpreter.cmx src/hopix/hopixInterpreter.ml
File "src/hopix/hopixInterpreter.ml", line 78, characters 10-21:
Warning 26: unused variable list_to_str.
File "src/hopix/hopixInterpreter.ml", line 116, characters 6-24:
Warning 26: unused variable print_record_value.
File "src/hopix/hopixInterpreter.ml", line 118, characters 6-17:
Warning 26: unused variable print_field.
File "src/hopix/hopixInterpreter.ml", line 114, characters 10-11:
Warning 11: this match case is unused.
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixLexer.cmx src/hopix/hopixLexer.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixPrettyPrinter.cmx src/hopix/hopixPrettyPrinter.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixTypechecker.cmx src/hopix/hopixTypechecker.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/syntacticAnalysis.cmx src/utilities/syntacticAnalysis.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopix.cmx src/hopix/hopix.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/stdUserInput.cmx src/utilities/stdUserInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/commandLineOptions.cmx src/commandLineOptions.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/hopix -I src -I src/common -I src/utilities -I src/lib/pprint -o src/hopix/hopixInitialization.cmx src/hopix/hopixInitialization.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src/utilities -I src -I src/common -I src/hopix -I src/lib/pprint -o src/utilities/userInput.cmx src/utilities/userInput.ml
ocamlfind ocamlopt -c -annot -bin-annot -package unix -package str -I src -I src/common -I src/hopix -I src/utilities -I src/lib/pprint -o src/flap.cmx src/flap.ml
ocamlfind ocamlopt -linkpkg -package unix -package str src/utilities/position.cmx src/utilities/error.cmx src/options.cmx src/version.cmx src/commandLineOptions.cmx src/common/languages.cmx src/utilities/extStd.cmx src/common/compilers.cmx src/hopix/hopixAST.cmx src/hopix/memory.cmx src/hopix/hopixInterpreter.cmx src/hopix/hopixParser.cmx src/hopix/hopixLexer.cmx src/lib/pprint/PPrintRenderer.cmx src/lib/pprint/PPrintEngine.cmx src/lib/pprint/PPrintCombinators.cmx src/lib/pprint/PPrintOCaml.cmx src/lib/pprint/PPrint.cmx src/utilities/extPPrint.cmx src/hopix/hopixPrettyPrinter.cmx src/hopix/hopixTypes.cmx src/hopix/hopixTypechecker.cmx src/utilities/syntacticAnalysis.cmx src/hopix/hopix.cmx src/hopix/hopixInitialization.cmx src/utilities/stdUserInput.cmx src/utilities/userInput.cmx src/flap.cmx -o src/flap.native
ln -s flap.native flap
=> Je lance les tests.
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make -C tests check
make[1]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests'
make -C ..
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2'
Source configuration ...
 * Ledit is not present: use default UserInput.
rm -f flap.native
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/bad'
========================================================
In interpreter/bad
GOOD: 0 / 0

BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/bad'
make[2]: Entering directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/good'
========================================================
In interpreter/good
[ OK ]   comment1.hopix

INPUT:
val a := 1.
val b := `+ 1 1.
OUTPUT: 
a = 1
b = 2
EXPECTED: 
a = 1
b = 2
--------------------------------------------------------
[ OK ]   comment2.hopix

INPUT:
val x := `+ 1 1.
val x := `+ 1 2.
val x := 3.
OUTPUT: 
x = 2
x = 3
x = 3
EXPECTED: 
x = 2
x = 3
x = 3
--------------------------------------------------------
[ OK ]   comment4.hopix

INPUT:

OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   do1.hopix

INPUT:
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
OUTPUT: 
seq3 = <fun>
EXPECTED: 
seq3 = <fun>
--------------------------------------------------------
[ OK ]   do2.hopix

INPUT:
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
OUTPUT: 
seq3 = <fun>
EXPECTED: 
seq3 = <fun>
--------------------------------------------------------
[ OK ]   do3.hopix

INPUT:
val f := \y => val nothing := y ? { | _ => 1 }; 2.
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   do4.hopix

INPUT:
val f := \y => val nothing := 1; y ? { | _ => 2 }.
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   do.hopix

INPUT:
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
val seq3 :=
  \i1 => \i2 => \i3 => val nothing := i1; val nothing := i2; i3.
val f := \y => val nothing := y ? { | _ => 1 }; 2.
val f := \y => val nothing := 1; y ? { | _ => 2 }.
OUTPUT: 
seq3 = <fun>
seq3 = <fun>
f = <fun>
f = <fun>
EXPECTED: 
seq3 = <fun>
seq3 = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ OK ]   extern1.hopix

INPUT:
extern something : int.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   extern2.hopix

INPUT:
extern some_function : int -> (int -> int) -> int.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   extern.hopix

INPUT:
extern something : int.
extern some_function : int -> (int -> int) -> int.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ OK ]   functions2.hopix

INPUT:
val f := \(x : int) => \(y : int) => (`+ x y : int).
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   functions3.hopix

INPUT:
val f := (\x => `+ x 1 : int -> int).
OUTPUT: 
f = <fun>
EXPECTED: 
f = <fun>
--------------------------------------------------------
[ OK ]   functions4.hopix

INPUT:
val g := \x => \y => `+ x y.
OUTPUT: 
g = <fun>
EXPECTED: 
g = <fun>
--------------------------------------------------------
[ OK ]   functions5.hopix

INPUT:
val g := \x => \y => `+ x y.
OUTPUT: 
g = <fun>
EXPECTED: 
g = <fun>
--------------------------------------------------------
[ OK ]   functions.hopix

INPUT:
val f := \x => \y => `+ x y.
val f := \(x : int) => \(y : int) => (`+ x y : int).
val f := (\x => `+ x 1 : int -> int).
val g := \x => \y => `+ x y.
val g := \x => \y => `+ x y.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
g = <fun>
g = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
g = <fun>
g = <fun>
--------------------------------------------------------
[ KO ]   -->  higherorderfind.hopix

INPUT:
type l := { N | I : int * l }.

val l := I (1, I (2, I (3, N))).

rec find k x l on_find on_error :=
  l ? {
  | N =>
    on_error k
  | I (y, ys) =>
    if x = y then on_find k else find (k + 1) x ys on_find on_error fi
  }.

val x := find 0 1 l (\x => true) (\x => false).

val y := find 0 0 l (\x => x) (\x => 0 - x).
OUTPUT: 
Failure("Mismatch failure")
EXPECTED: 
l = I(1, I(2, I(3, N)))
find = <fun>
x = true
y = -3
--------------------------------------------------------
[ OK ]   infix1.hopix

INPUT:
val `++ := \x => \y => x.
OUTPUT: 
`++ = <fun>
EXPECTED: 
`++ = <fun>
--------------------------------------------------------
[ OK ]   infix2.hopix

INPUT:
val `++ := \x => \y => y.
val z := `++ 0 1.
OUTPUT: 
`++ = <fun>
z = 1
EXPECTED: 
`++ = <fun>
z = 1
--------------------------------------------------------
[ OK ]   infix3.hopix

INPUT:
val `++ := \x => \y => x.
val k := `++ 0 1.
OUTPUT: 
`++ = <fun>
k = 0
EXPECTED: 
`++ = <fun>
k = 0
--------------------------------------------------------
[ OK ]   infix4.hopix

INPUT:
val `eats := \x => \y => x.
OUTPUT: 
`eats = <fun>
EXPECTED: 
`eats = <fun>
--------------------------------------------------------
[ OK ]   infix5.hopix

INPUT:
val wow := \cat => \mouse => `eats cat mouse.
OUTPUT: 
wow = <fun>
EXPECTED: 
wow = <fun>
--------------------------------------------------------
[ OK ]   infix6.hopix

INPUT:
val apply := \`op => \x => \y => `op x y.
OUTPUT: 
apply = <fun>
EXPECTED: 
apply = <fun>
--------------------------------------------------------
[ OK ]   infix7.hopix

INPUT:
val apply := \`op => \x => \y => `op x y.
OUTPUT: 
apply = <fun>
EXPECTED: 
apply = <fun>
--------------------------------------------------------
[ OK ]   infix.hopix

INPUT:
val `++ := \x => \y => x.
val z := `++ 0 0.
val k := `++ 0 0.
val `eats := \x => \y => x.
val wow := \cat => \mouse => `eats cat mouse.
val apply := \`op => \x => \y => `op x y.
val apply := \`op => \x => \y => `op x y.
OUTPUT: 
`++ = <fun>
z = 0
k = 0
`eats = <fun>
wow = <fun>
apply = <fun>
apply = <fun>
EXPECTED: 
`++ = <fun>
z = 0
k = 0
`eats = <fun>
wow = <fun>
apply = <fun>
apply = <fun>
--------------------------------------------------------
[ KO ]   -->  lexchar10.hopix

INPUT:
val x := '\r'.
OUTPUT: 
x = \r
EXPECTED: 
x = '\r'
--------------------------------------------------------
[ KO ]   -->  lexchar11.hopix

INPUT:
val x := '\000'.
OUTPUT: 
x = \000
EXPECTED: 
x = '\000'
--------------------------------------------------------
[ KO ]   -->  lexchar12.hopix

INPUT:
val x := '\001'.
OUTPUT: 
x = \001
EXPECTED: 
x = '\001'
--------------------------------------------------------
[ KO ]   -->  lexchar13.hopix

INPUT:
val x := '\255'.
OUTPUT: 
x = \255
EXPECTED: 
x = '\255'
--------------------------------------------------------
[ KO ]   -->  lexchar14.hopix

INPUT:
val x := '\255'.
OUTPUT: 
x = \255
EXPECTED: 
x = '\255'
--------------------------------------------------------
[ KO ]   -->  lexchar15.hopix

INPUT:
val x := '\171'.
OUTPUT: 
x = \171
EXPECTED: 
x = '\171'
--------------------------------------------------------
[ KO ]   -->  lexchar16.hopix

INPUT:
val x := '\018'.
OUTPUT: 
x = \018
EXPECTED: 
x = '\018'
--------------------------------------------------------
[ KO ]   -->  lexchar17.hopix

INPUT:
val x := '\204'.
OUTPUT: 
x = \204
EXPECTED: 
x = '\204'
--------------------------------------------------------
[ KO ]   -->  lexchar18.hopix

INPUT:
val x := '\204'.
OUTPUT: 
x = \204
EXPECTED: 
x = '\204'
--------------------------------------------------------
[ KO ]   -->  lexchar1.hopix

INPUT:
val x := 'a'.
OUTPUT: 
x = a
EXPECTED: 
x = 'a'
--------------------------------------------------------
[ KO ]   -->  lexchar2.hopix

INPUT:
val x := 'A'.
OUTPUT: 
x = A
EXPECTED: 
x = 'A'
--------------------------------------------------------
[ KO ]   -->  lexchar3.hopix

INPUT:
val x := '*'.
OUTPUT: 
x = *
EXPECTED: 
x = '*'
--------------------------------------------------------
[ KO ]   -->  lexchar4.hopix

INPUT:
val x := '@'.
OUTPUT: 
x = @
EXPECTED: 
x = '@'
--------------------------------------------------------
[ KO ]   -->  lexchar5.hopix

INPUT:
val x := '\\'.
OUTPUT: 
x = \\
EXPECTED: 
x = '\\'
--------------------------------------------------------
[ KO ]   -->  lexchar6.hopix

INPUT:
val x := '\''.
OUTPUT: 
x = \'
EXPECTED: 
x = '\''
--------------------------------------------------------
[ KO ]   -->  lexchar7.hopix

INPUT:
val x := '\n'.
OUTPUT: 
x = \n
EXPECTED: 
x = '\n'
--------------------------------------------------------
[ KO ]   -->  lexchar8.hopix

INPUT:
val x := '\t'.
OUTPUT: 
x = \t
EXPECTED: 
x = '\t'
--------------------------------------------------------
[ KO ]   -->  lexchar9.hopix

INPUT:
val x := '\b'.
OUTPUT: 
x = \b
EXPECTED: 
x = '\b'
--------------------------------------------------------
[ KO ]   -->  lexchar.hopix

INPUT:
val x := 'a'.
val x := 'A'.
val x := '*'.
val x := '@'.
val x := '\\'.
val x := '\''.
val x := '\n'.
val x := '\t'.
val x := '\b'.
val x := '\r'.
val x := '\000'.
val x := '\001'.
val x := '\255'.
val x := '\255'.
val x := '\171'.
val x := '\018'.
val x := '\204'.
val x := '\204'.
OUTPUT: 
x = a
x = A
x = *
x = @
x = \\
x = \'
x = \n
x = \t
x = \b
x = \r
x = \000
x = \001
x = \255
x = \255
x = \171
x = \018
x = \204
x = \204
EXPECTED: 
x = 'a'
x = 'A'
x = '*'
x = '@'
x = '\\'
x = '\''
x = '\n'
x = '\t'
x = '\b'
x = '\r'
x = '\000'
x = '\001'
x = '\255'
x = '\255'
x = '\171'
x = '\018'
x = '\204'
x = '\204'
--------------------------------------------------------
[ OK ]   lexnum1.hopix

INPUT:
val x := 0.
OUTPUT: 
x = 0
EXPECTED: 
x = 0
--------------------------------------------------------
[ OK ]   lexnum2.hopix

INPUT:
val x := 1234567890.
OUTPUT: 
x = 1234567890
EXPECTED: 
x = 1234567890
--------------------------------------------------------
[ OK ]   lexnum3.hopix

INPUT:
val x := 233495534.
OUTPUT: 
x = 233495534
EXPECTED: 
x = 233495534
--------------------------------------------------------
[ OK ]   lexnum4.hopix

INPUT:
val x := 233495534.
OUTPUT: 
x = 233495534
EXPECTED: 
x = 233495534
--------------------------------------------------------
[ OK ]   lexnum5.hopix

INPUT:
val x := 305419896.
OUTPUT: 
x = 305419896
EXPECTED: 
x = 305419896
--------------------------------------------------------
[ OK ]   lexnum6.hopix

INPUT:
val x := 559038737.
OUTPUT: 
x = 559038737
EXPECTED: 
x = 559038737
--------------------------------------------------------
[ OK ]   lexnum7.hopix

INPUT:
val x := 42.
OUTPUT: 
x = 42
EXPECTED: 
x = 42
--------------------------------------------------------
[ OK ]   lexnum.hopix

INPUT:
val x := 0.
val x := 1234567890.
val x := 233495534.
val x := 233495534.
val x := 305419896.
val x := 559038737.
val x := 42.
val x := 42.
OUTPUT: 
x = 0
x = 1234567890
x = 233495534
x = 233495534
x = 305419896
x = 559038737
x = 42
x = 42
EXPECTED: 
x = 0
x = 1234567890
x = 233495534
x = 233495534
x = 305419896
x = 559038737
x = 42
x = 42
--------------------------------------------------------
[ KO ]   -->  lexstring1.hopix

INPUT:
val x := "".
OUTPUT: 
x = 
EXPECTED: 
x = ""
--------------------------------------------------------
[ KO ]   -->  lexstring2.hopix

INPUT:
val x := "abc".
OUTPUT: 
x = abc
EXPECTED: 
x = "abc"
--------------------------------------------------------
[ KO ]   -->  lexstring3.hopix

INPUT:
val x := "**".
OUTPUT: 
x = **
EXPECTED: 
x = "**"
--------------------------------------------------------
[ KO ]   -->  lexstring4.hopix

INPUT:
val x := "{*".
OUTPUT: 
x = {*
EXPECTED: 
x = "{*"
--------------------------------------------------------
[ KO ]   -->  lexstring5.hopix

INPUT:
val x := "*}".
OUTPUT: 
x = *}
EXPECTED: 
x = "*}"
--------------------------------------------------------
[ KO ]   -->  lexstring6.hopix

INPUT:
val x := "a'a".
OUTPUT: 
x = a'a
EXPECTED: 
x = "a'a"
--------------------------------------------------------
[ KO ]   -->  lexstring.hopix

INPUT:
val x := "".
val x := "abc".
val x := "**".
val x := "{*".
val x := "*}".
val x := "a'a".
OUTPUT: 
x = 
x = abc
x = **
x = {*
x = *}
x = a'a
EXPECTED: 
x = ""
x = "abc"
x = "**"
x = "{*"
x = "*}"
x = "a'a"
--------------------------------------------------------
[ KO ]   -->  list.hopix

INPUT:
type list := { Cons : int * list | Nil }.
rec
 map :=
  \f =>
    \l =>
      (l ? { | Nil => Nil | Cons (x, xs) => Cons (f x, map f xs) }
      : list).
rec
 append :=
  \l1 =>
    \l2 =>
      (l1 ? { | Nil => l2 | Cons (x, xs) => Cons (x, append xs l2) }
      : list).
rec
 sum :=
  \l1 =>
    \l2 =>
      (l1 ?
      {
      | Nil => l2 ? { | _ => l2 }
      | Cons (x, xs) =>
        l2 ? { | Cons (y, ys) => Cons (`+ x y, sum xs ys) | _ => l1 }
      }
      : list).

val a := Cons (1, Cons (2, Nil)).
val b := Cons (3, Cons (4, Cons (5, Nil))).

val ab := append a b.
val sumab := sum a a.
val shifta := map (\x => x + 1) a.
val complex := sum (map (\x => x * 2 + 1) (append b (append ab a))) a.
OUTPUT: 
Failure("Mismatch failure")
EXPECTED: 
map = <fun>
append = <fun>
sum = <fun>
a = Cons(1, Cons(2, Nil))
b = Cons(3, Cons(4, Cons(5, Nil)))
ab = Cons(1, Cons(2, Cons(3, Cons(4, Cons(..., ...)))))
sumab = Cons(2, Cons(4, Nil))
shifta = Cons(2, Cons(3, Nil))
complex = Cons(8, Cons(11, Cons(11, Cons(3, Cons(..., ...)))))
--------------------------------------------------------
[ OK ]   localdef1.hopix

INPUT:
val x := val y := 1; val z := 2; `+ y z.
OUTPUT: 
x = 3
EXPECTED: 
x = 3
--------------------------------------------------------
[ OK ]   localdef2.hopix

INPUT:
val x := `+ 1 (val y := 1; val z := 2; `+ y z).
OUTPUT: 
x = 4
EXPECTED: 
x = 4
--------------------------------------------------------
[ OK ]   localdef3.hopix

INPUT:
val x :=
  val y := val z := 1; `* 2 z; val t := val u := 2; `* 2 u; `* y t.
OUTPUT: 
x = 8
EXPECTED: 
x = 8
--------------------------------------------------------
[ OK ]   localdef4.hopix

INPUT:
val even :=
  rec
     even := \x => if `= x 0 then true else odd (`- x 1) fi
    and
     odd := \x => if `= x 0 then false else even (`- x 1) fi;
  even 10.
OUTPUT: 
even = true
EXPECTED: 
even = true
--------------------------------------------------------
[ OK ]   localdef.hopix

INPUT:
val x := val y := 1; val z := 2; `+ y z.
val x := `+ 1 (val y := 1; val z := 2; `+ y z).
val x :=
  val y := val z := 1; `* 2 z; val t := val u := 2; `* 2 u; `* y t.
val even :=
  rec
     even := \x => if `= x 0 then true else odd (`- x 1) fi
    and
     odd := \x => if `= x 0 then false else even (`- x 1) fi;
  even x.
OUTPUT: 
x = 3
x = 4
x = 8
even = true
EXPECTED: 
x = 3
x = 4
x = 8
even = true
--------------------------------------------------------
[ OK ]   match11.hopix

INPUT:
type enum := { A | B | C | D }.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  match12.hopix

INPUT:
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val x := f D + f C + f B + f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 10
--------------------------------------------------------
[ KO ]   -->  match13.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f D + f C + f B + f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 10
--------------------------------------------------------
[ KO ]   -->  match14.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f D + f C * f B - f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 11
--------------------------------------------------------
[ KO ]   -->  match15.hopix

INPUT:
val f := \x => \y => x ? { | A => y ? { | B => C } }.
val x := f A B.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = C
--------------------------------------------------------
[ OK ]   match1.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => \y => x ? { | A => y ? { | B => C } }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ OK ]   match21.hopix

INPUT:
type enum := { A | B | C | D }.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  match22.hopix

INPUT:
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val x := f A + f C * f B - f D.

OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match23.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f A + f C * f B - f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 7
--------------------------------------------------------
[ KO ]   -->  match24.hopix

INPUT:
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val x := f A + f C * f B - f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 7
--------------------------------------------------------
[ KO ]   -->  match25.hopix

INPUT:
val f := \x => \y => x ? { | A => y ? { | B => C } }.
val x := f A B.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = C
--------------------------------------------------------
[ OK ]   match2.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | A => 1 | B => 2 | C => 3 | D => 4 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => x ? { | A => 1 | (B | C | D) => 3 }.
val f := \x => \y => x ? { | A => y ? { | B => C } }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ KO ]   -->  match31.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val x := f A + f B - f C * f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
--------------------------------------------------------
[ KO ]   -->  match32.hopix

INPUT:
val f := \x => x ? { | (A | B | C | D) => 1 }.
val x := f A + f B - f C * f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
--------------------------------------------------------
[ KO ]   -->  match33.hopix

INPUT:
val f := \x => x ? { | (A | B | C | D) => 1 }.
val x := f A + f B - f C * f D.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
--------------------------------------------------------
[ KO ]   -->  match34.hopix

INPUT:
val f := \x => x ? { | (A & B & C & D) => 1 | _ => 0 }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 0
--------------------------------------------------------
[ KO ]   -->  match35.hopix

INPUT:
val f := \x => x ? { | (A & B & C & D) => 1 | _ => 0 }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 0
--------------------------------------------------------
[ KO ]   -->  match36.hopix

INPUT:
val f := \x => x ? { | (A & B & C & D) => 1 | _ => 0 }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 0
--------------------------------------------------------
[ KO ]   -->  match37.hopix

INPUT:
val f := \x => x ? { | ((A | B) & y & _) => y | C => A }.
val x := f A.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = A
--------------------------------------------------------
[ KO ]   -->  match38.hopix

INPUT:
val f := \x => x ? { | (A | (B & y) | _) => 1 | C => 0 }.
val x := f A.
val y := f B.
val z := f C.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
f = <fun>
x = 1
y = 1
z = 1
--------------------------------------------------------
[ OK ]   match3.hopix

INPUT:
type enum := { A | B | C | D }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val f := \x => x ? { | (A | B | C | D) => 1 }.
val f := \x => x ? { | (A & B & C & D) => 1 }.
val f := \x => x ? { | (A & B & C & D) => 1 }.
val f := \x => x ? { | (A & B & C & D) => 1 }.
val f := \x => x ? { | ((A | B) & y & (B | C) & _) => y }.
val f := \x => x ? { | (A | (B & y) | _) => 1 }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ OK ]   match41.hopix

INPUT:
type record := { aaa : int ; bbb : int }.

OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  match42.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match43.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match44.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ KO ]   -->  match45.hopix

INPUT:
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val x := f ({ aaa := 1; bbb := 2 }).
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
x = 3
--------------------------------------------------------
[ OK ]   match4.hopix

INPUT:
type record := { aaa : int ; bbb : int }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
val f := \x => x ? { | { aaa = a; bbb = b } => `+ a b }.
OUTPUT: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
EXPECTED: 
f = <fun>
f = <fun>
f = <fun>
f = <fun>
--------------------------------------------------------
[ KO ]   -->  merge.hopix

INPUT:
type nat := { Z | S : nat }.

rec gt x y :=
  x ? { Z => false | S (x) =>
    y ? { Z => true | S (y) =>
      gt x y
    }
  }.

rec int2nat n :=
  if n = 0 then Z else S (int2nat (n - 1)) fi.

rec nat2int n :=
  n ? { Z => 0 | S (k) => 1 + nat2int k }.

type ilist := { I : int * ilist | N }.

type list := { Cons : nat * list | Nil }.

rec i2l l :=
  l ? { N => Nil | I (x, l) => Cons (int2nat x, i2l l) }.

rec l2i l :=
  l ? { Nil => N | Cons (x, l) => I (nat2int x, l2i l) }.

rec merge l1 l2 :=
  l1 ? { Nil => l2 | Cons (x, xs) =>
  l2 ? { Nil => l1 | Cons (y, ys) =>
    if gt x y then
      Cons (y, merge l1 ys)
    else
      Cons (x, merge xs l2)
    fi
  }}.

type pair := { Pair : list * list }.

val bnot b :=
 if b then false else true fi.

rec split turn l :=
  l ? { Nil => Pair (Nil, Nil) | Cons (x, xs) =>
     split (bnot turn) xs ? Pair (a, b) =>
     if turn then Pair (Cons (x, a), b) else Pair (a, Cons (x, b)) fi
  }.

rec sort l :=
  l ? {
  | Nil => Nil
  | Cons (x, Nil) => Cons (x, Nil)
  | _ =>
    split true l ? Pair (a, b) =>
    merge (sort a) (sort b)
  }.


val l1 := l2i (sort (i2l (I (1, I (0, I (5, I (3, I (4, I (1, I (9, N)))))))))).

type o := { None | Some : int }.

rec take n l :=
  l ? {
  | N => None
  | I (x, xs) =>
    if n = 0 then Some (x) else take (n - 1) xs fi
  }.

val x6 := take 6 l1.
val x5 := take 5 l1.
val x4 := take 4 l1.
val x3 := take 3 l1.
val x2 := take 2 l1.
val x1 := take 1 l1.
val x0 := take 0 l1.
OUTPUT: 
Failure("Mismatch failure")
EXPECTED: 
gt = <fun>
int2nat = <fun>
nat2int = <fun>
i2l = <fun>
l2i = <fun>
merge = <fun>
bnot = <fun>
split = <fun>
sort = <fun>
l1 = I(0, I(1, I(1, I(3, I(..., ...)))))
take = <fun>
x6 = Some(9)
x5 = Some(5)
x4 = Some(4)
x3 = Some(3)
x2 = Some(1)
x1 = Some(1)
x0 = Some(0)
--------------------------------------------------------
[ KO ]   -->  mutrecfun.hopix

INPUT:
rec
 odd :=
  \(n : int) =>
    (if `= n 0 then false
    else if `= n 1 then true else even (`- n 1) fi fi
    : int)
and even :=
  \(n : int) =>
    (if `= n 0 then true
    else if `= n 1 then false else odd (`- n 1) fi fi
    : int).

val x := even 42.
OUTPUT: 
File "src/hopix/hopixInterpreter.ml", line 312, characters 8-14: Assertion failed
EXPECTED: 
odd = <fun>
even = <fun>
x = true
--------------------------------------------------------
[ OK ]   partial.hopix

INPUT:
val f x :=
   val y := x * 2;
   \z => x + y + z.

val z := f 1 2.
val g := f 8.
val t := g 3.
val u := g 4.

OUTPUT: 
f = <fun>
z = 5
g = <fun>
t = 27
u = 28
EXPECTED: 
f = <fun>
z = 5
g = <fun>
t = 27
u = 28
--------------------------------------------------------
[ OK ]   pri_app1.hopix

INPUT:
val f x := x * x.
val a := 1.
val b := 3.
val x := `+ (f a) b.
OUTPUT: 
f = <fun>
a = 1
b = 3
x = 4
EXPECTED: 
f = <fun>
a = 1
b = 3
x = 4
--------------------------------------------------------
[ KO ]   -->  pri_app2.hopix

INPUT:
val f x := x * x.
val a := { b := 3 }.
val x := f a#b.
OUTPUT: 
Failure("salut")
EXPECTED: 
f = <fun>
a = { b = 3 }
x = 9
--------------------------------------------------------
[ OK ]   pri_app3.hopix

INPUT:
val f g x := g x * x.
val a := 1.
val g x := 3 + x.
val x := f g a.
OUTPUT: 
f = <fun>
a = 1
g = <fun>
x = 4
EXPECTED: 
f = <fun>
a = 1
g = <fun>
x = 4
--------------------------------------------------------
[ OK ]   pri_arith1.hopix

INPUT:
val x := `+ (`+ 1 2) 3.
OUTPUT: 
x = 6
EXPECTED: 
x = 6
--------------------------------------------------------
[ OK ]   pri_arith2.hopix

INPUT:
val x := `+ (`- (`- (`+ 1 2) 3) 4) 5.
OUTPUT: 
x = 1
EXPECTED: 
x = 1
--------------------------------------------------------
[ OK ]   pri_arith3.hopix

INPUT:
val x := `* (`* 1 2) 3.
OUTPUT: 
x = 6
EXPECTED: 
x = 6
--------------------------------------------------------
[ OK ]   pri_arith4.hopix

INPUT:
val x := `/ (`/ 1 2) 3.
OUTPUT: 
x = 0
EXPECTED: 
x = 0
--------------------------------------------------------
[ OK ]   pri_arith5.hopix

INPUT:
val x := `* (`/ (`/ (`* 1 2) 3) 4) 5.
OUTPUT: 
x = 0
EXPECTED: 
x = 0
--------------------------------------------------------
[ OK ]   pri_arith6.hopix

INPUT:
val x := `- (`+ 1 (`* 2 3)) 4.
OUTPUT: 
x = 3
EXPECTED: 
x = 3
--------------------------------------------------------
[ OK ]   pri_arith7.hopix

INPUT:
val x := `+ (`- (`+ 1 (`* 2 3)) (`/ 4 5)) 6.
OUTPUT: 
x = 13
EXPECTED: 
x = 13
--------------------------------------------------------
[ OK ]   pri_arith8.hopix

INPUT:
val x := `* (`+ 1 2) 3.
OUTPUT: 
x = 9
EXPECTED: 
x = 9
--------------------------------------------------------
[ OK ]   pri_arith.hopix

INPUT:
val x := `+ (`+ 1 2) 3.
val x := `+ (`- (`- (`+ 1 2) 3) 4) 5.
val x := `* (`* 1 2) 3.
val x := `/ (`/ 1 2) 3.
val x := `* (`/ (`/ (`* 1 2) 3) 4) 5.
val x := `- (`+ 1 (`* 2 3)) 4.
val x := `+ (`- (`+ 1 (`* 2 3)) (`/ 4 5)) 6.
val x := `* (`+ 1 2) 3.
OUTPUT: 
x = 6
x = 1
x = 6
x = 0
x = 0
x = 3
x = 13
x = 9
EXPECTED: 
x = 6
x = 1
x = 6
x = 0
x = 0
x = 3
x = 13
x = 9
--------------------------------------------------------
[ OK ]   pri_comp1.hopix

INPUT:
val x := `= 2 (`+ 1 1).
OUTPUT: 
x = true
EXPECTED: 
x = true
--------------------------------------------------------
[ KO ]   -->  pri_comp2.hopix

INPUT:
val x := true || true && true && true.
OUTPUT: 
HopixInterpreter.Environment.UnboundIdentifier(_)
EXPECTED: 
x = true
--------------------------------------------------------
[ KO ]   -->  pri_comp3.hopix

INPUT:
val x := 1 + 1 < 2 + 2 && 4 = 7.

OUTPUT: 
HopixInterpreter.Environment.UnboundIdentifier(_)
EXPECTED: 
x = false
--------------------------------------------------------
[ OK ]   pri_infix.hopix

INPUT:
val `op x y := x - y * x.
val x := 1 = (`op (1 `op` 2) (`+ 3 3)). 
OUTPUT: 
`op = <fun>
x = false
EXPECTED: 
`op = <fun>
x = false
--------------------------------------------------------
[ KO ]   -->  pri_larrow1.hopix

INPUT:
val t := { a := 0 }.
val x := t#a <- `+ 1 2.
val z := t#a.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = 3 }
x = ()
z = 3
--------------------------------------------------------
[ KO ]   -->  pri_larrow2.hopix

INPUT:
val t := { a := false }.
val x := t#a <- true || false.
val y := t#a.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = true }
x = ()
y = true
--------------------------------------------------------
[ KO ]   -->  pri_larrow3.hopix

INPUT:
val t := { a := 3 }.
val x := t#a <- (t ? { | _ => 1 }).
val y := t#a.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = 1 }
x = ()
y = 1
--------------------------------------------------------
[ OK ]   pri_qmark1.hopix

INPUT:
val x := 2.
val y := `* x (x ? { | _ => 3 }).
OUTPUT: 
x = 2
y = 6
EXPECTED: 
x = 2
y = 6
--------------------------------------------------------
[ KO ]   -->  pri_qmark2.hopix

INPUT:
val x := { a := 1 }.
val y := x#a ? { | z => z + 2 }.
OUTPUT: 
Failure("salut")
EXPECTED: 
x = { a = 1 }
y = 3
--------------------------------------------------------
[ OK ]   pri_rarrow1.hopix

INPUT:
val x := \x => `+ x x.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow2.hopix

INPUT:
val x := \x => x && x.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow3.hopix

INPUT:
val x := \x => x#a <- 1.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow4.hopix

INPUT:
val x := val f := \x => x; f.
OUTPUT: 
x = <fun>
EXPECTED: 
x = <fun>
--------------------------------------------------------
[ OK ]   pri_rarrow5.hopix

INPUT:
val x := val f := \y => y ? { | _ => 1 }; f 1.
OUTPUT: 
x = 1
EXPECTED: 
x = 1
--------------------------------------------------------
[ OK ]   pri_rarrow.hopix

INPUT:
val x := \x => `+ x x.
val x := \x => x && x.
val x := \x => x#a <- 1.
val x := val f := \x => x; f.
val x := val f := \y => y ? { | _ => 1 }; f 1.
OUTPUT: 
x = <fun>
x = <fun>
x = <fun>
x = <fun>
x = 1
EXPECTED: 
x = <fun>
x = <fun>
x = <fun>
x = <fun>
x = 1
--------------------------------------------------------
[ OK ]   pri_scolon1.hopix

INPUT:
val x := val y := `+ 1 1; `+ y y.
OUTPUT: 
x = 4
EXPECTED: 
x = 4
--------------------------------------------------------
[ KO ]   -->  pri_scolon2.hopix

INPUT:
val x := val y := true; y || false.
OUTPUT: 
HopixInterpreter.Environment.UnboundIdentifier(_)
EXPECTED: 
x = true
--------------------------------------------------------
[ OK ]   pri_scolon3.hopix

INPUT:
val x := val y := 1; y ? { | _ => 2 }.
OUTPUT: 
x = 2
EXPECTED: 
x = 2
--------------------------------------------------------
[ KO ]   -->  pri_sharp1.hopix

INPUT:
val t := { a := { b := 42 } }.
val x := t#a#b.
OUTPUT: 
Failure("salut")
EXPECTED: 
t = { a = { b = 42 } }
x = 42
--------------------------------------------------------
[ KO ]   -->  pri_sharp2.hopix

INPUT:
val t := { a := 3 }.
val x := `* t#a 3.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
t = { a = 3 }
x = 9
--------------------------------------------------------
[ KO ]   -->  pri_sharp.hopix

INPUT:
val t := { a := { b := 3 } }.
val x := t#a#b.
val u := { a := t#a#b }.
val x := `* u#a 3.
OUTPUT: 
Global Error (during parsing)
  Syntax error.
EXPECTED: 
t = { a = { b = 3 } }
x = 3
u = { a = 3 }
x = 9
--------------------------------------------------------
[ KO ]   -->  recfun.hopix

INPUT:
rec
 fact :=
  \(n : int) =>
    (if `= n 0 then 1 else `* n (fact (`- n 1)) fi : int).

val hundredandtwenty := fact 5.
OUTPUT: 
File "src/hopix/hopixInterpreter.ml", line 312, characters 8-14: Assertion failed
EXPECTED: 
fact = <fun>
hundredandtwenty = 120
--------------------------------------------------------
[ OK ]   record1.hopix

INPUT:
type point := { x : int ; y : int }.
OUTPUT: 

EXPECTED: 

--------------------------------------------------------
[ KO ]   -->  record2.hopix

INPUT:
val p := { x := 2; y := 3 }.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 2; y = 3 }
--------------------------------------------------------
[ KO ]   -->  record3.hopix

INPUT:
val p := { x := 3 + 3 }.
val y := p#x.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 6 }
y = 6
--------------------------------------------------------
[ KO ]   -->  record4.hopix

INPUT:
val p := { x := 0 }.
val u := p#x <- 3.
val z := p#x.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 3 }
u = ()
z = 3
--------------------------------------------------------
[ KO ]   -->  record.hopix

INPUT:
type point := { x : int ; y : int }.
val p := { x := 2; y := 3 }.
val y := p#x.
val u := p#x <- 3.
OUTPUT: 
Failure("salut")
EXPECTED: 
p = { x = 3; y = 3 }
y = 2
u = ()
--------------------------------------------------------
GOOD: 68 / 134
BAD:  0 / 0
make[2]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests/hopix/interpreter/good'
--------------------------------------------------------
Global results:
BAD:   0 / 0
GOOD:  68 / 134
--------------------------------------------------------
make[1]: Leaving directory '/home/user1/answer/flap-uzenat-elouraoui-15.2/tests'
